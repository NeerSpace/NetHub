//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_URL = new InjectionToken<string>('API_URL');

@Injectable()
export class ArticlesApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getById(id: number): Observable<ArticleModel> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ArticleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArticleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filters (optional) 
     * @param sorts (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    filter(filters: string | undefined, sorts: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<ArticleModelFiltered> {
        let url_ = this.baseUrl + "/v1/articles?";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts === null)
            throw new Error("The parameter 'sorts' cannot be null.");
        else if (sorts !== undefined)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleModelFiltered>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleModelFiltered>;
        }));
    }

    protected processFilter(response: HttpResponseBase): Observable<ArticleModelFiltered> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArticleModelFiltered.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: ArticleModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getByArticleId(id: number): Observable<ArticleLocalizationModel[]> {
        let url_ = this.baseUrl + "/v1/articles/{id}/localizations";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByArticleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByArticleId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleLocalizationModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleLocalizationModel[]>;
        }));
    }

    protected processGetByArticleId(response: HttpResponseBase): Observable<ArticleLocalizationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JWTApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    authenticate(body: AuthRequest | undefined): Observable<AuthResult> {
        let url_ = this.baseUrl + "/v1/jwt/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AuthResult.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Created
     */
    refresh(): Observable<AuthResult> {
        let url_ = this.baseUrl + "/v1/jwt/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthResult>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<AuthResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AuthResult.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Created
     */
    revokeToken(): Observable<void> {
        let url_ = this.baseUrl + "/v1/auth/revoke-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevokeToken(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguagesApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getByCode(code: string): Observable<LanguageModel> {
        let url_ = this.baseUrl + "/v1/languages/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageModel>;
        }));
    }

    protected processGetByCode(response: HttpResponseBase): Observable<LanguageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    delete(code: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/languages/{code}";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: LanguageModel | undefined): Observable<LanguageModel> {
        let url_ = this.baseUrl + "/v1/languages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LanguageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LanguageModel.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filters (optional) 
     * @param sorts (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    filter(filters: string | undefined, sorts: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<LanguageModelFiltered> {
        let url_ = this.baseUrl + "/v1/languages?";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts === null)
            throw new Error("The parameter 'sorts' cannot be null.");
        else if (sorts !== undefined)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageModelFiltered>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageModelFiltered>;
        }));
    }

    protected processFilter(response: HttpResponseBase): Observable<LanguageModelFiltered> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageModelFiltered.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: LanguageModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/languages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LocalizationsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getById(id: number): Observable<ArticleLocalizationModel> {
        let url_ = this.baseUrl + "/v1/localizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ArticleLocalizationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ArticleLocalizationModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ArticleLocalizationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ArticleLocalizationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/localizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: ArticleLocalization | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/localizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionsApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<PermissionModel[]> {
        let url_ = this.baseUrl + "/v1/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionModel[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PermissionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RolesApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getById(id: number): Observable<RoleModel> {
        let url_ = this.baseUrl + "/v1/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RoleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: RoleModel | undefined): Observable<RoleModel> {
        let url_ = this.baseUrl + "/v1/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RoleModel.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filters (optional) 
     * @param sorts (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    filter(filters: string | undefined, sorts: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<RoleModelFiltered> {
        let url_ = this.baseUrl + "/v1/roles?";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts === null)
            throw new Error("The parameter 'sorts' cannot be null.");
        else if (sorts !== undefined)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModelFiltered>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModelFiltered>;
        }));
    }

    protected processFilter(response: HttpResponseBase): Observable<RoleModelFiltered> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleModelFiltered.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleModel | undefined): Observable<RoleModel> {
        let url_ = this.baseUrl + "/v1/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UsersApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getById(id: number): Observable<UserModel> {
        let url_ = this.baseUrl + "/v1/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/v1/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: UserCreateRequest | undefined): Observable<UserModel> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserModel.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filters (optional) 
     * @param sorts (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    filter(filters: string | undefined, sorts: string | undefined, page: number | undefined, pageSize: number | undefined): Observable<UserModelFiltered> {
        let url_ = this.baseUrl + "/v1/users?";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorts === null)
            throw new Error("The parameter 'sorts' cannot be null.");
        else if (sorts !== undefined)
            url_ += "Sorts=" + encodeURIComponent("" + sorts) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModelFiltered>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModelFiltered>;
        }));
    }

    protected processFilter(response: HttpResponseBase): Observable<UserModelFiltered> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModelFiltered.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: UserUpdateRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    me(): Observable<UserModel> {
        let url_ = this.baseUrl + "/v1/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserModel>;
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AppDevice implements IAppDevice {
    id!: number;
    ipAddress!: string;
    platform!: string;
    browser!: string;
    browserVersion!: string;
    status!: DeviceStatus;
    attemptCount!: number;
    lastAttempt!: DateTime | null;

    constructor(data?: IAppDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.platform = _data["platform"] !== undefined ? _data["platform"] : <any>null;
            this.browser = _data["browser"] !== undefined ? _data["browser"] : <any>null;
            this.browserVersion = _data["browserVersion"] !== undefined ? _data["browserVersion"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.attemptCount = _data["attemptCount"] !== undefined ? _data["attemptCount"] : <any>null;
            this.lastAttempt = _data["lastAttempt"] ? DateTime.fromISO(_data["lastAttempt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AppDevice {
        data = typeof data === 'object' ? data : {};
        let result = new AppDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["platform"] = this.platform !== undefined ? this.platform : <any>null;
        data["browser"] = this.browser !== undefined ? this.browser : <any>null;
        data["browserVersion"] = this.browserVersion !== undefined ? this.browserVersion : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["attemptCount"] = this.attemptCount !== undefined ? this.attemptCount : <any>null;
        data["lastAttempt"] = this.lastAttempt ? this.lastAttempt.toString() : <any>null;
        return data;
    }
}

export interface IAppDevice {
    id: number;
    ipAddress: string;
    platform: string;
    browser: string;
    browserVersion: string;
    status: DeviceStatus;
    attemptCount: number;
    lastAttempt: DateTime | null;
}

export class AppRole implements IAppRole {
    id!: number;
    name!: string;
    normalizedName!: string;
    concurrencyStamp!: string;
    userRoles!: AppUserRole[] | null;
    roleClaims!: AppRoleClaim[] | null;

    constructor(data?: IAppRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.userRoles) {
                this.userRoles = [];
                for (let i = 0; i < data.userRoles.length; i++) {
                    let item = data.userRoles[i];
                    this.userRoles[i] = item && !(<any>item).toJSON ? new AppUserRole(item) : <AppUserRole>item;
                }
            }
            if (data.roleClaims) {
                this.roleClaims = [];
                for (let i = 0; i < data.roleClaims.length; i++) {
                    let item = data.roleClaims[i];
                    this.roleClaims[i] = item && !(<any>item).toJSON ? new AppRoleClaim(item) : <AppRoleClaim>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.normalizedName = _data["normalizedName"] !== undefined ? _data["normalizedName"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(AppUserRole.fromJS(item));
            }
            else {
                this.userRoles = <any>null;
            }
            if (Array.isArray(_data["roleClaims"])) {
                this.roleClaims = [] as any;
                for (let item of _data["roleClaims"])
                    this.roleClaims!.push(AppRoleClaim.fromJS(item));
            }
            else {
                this.roleClaims = <any>null;
            }
        }
    }

    static fromJS(data: any): AppRole {
        data = typeof data === 'object' ? data : {};
        let result = new AppRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["normalizedName"] = this.normalizedName !== undefined ? this.normalizedName : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.roleClaims)) {
            data["roleClaims"] = [];
            for (let item of this.roleClaims)
                data["roleClaims"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppRole {
    id: number;
    name: string;
    normalizedName: string;
    concurrencyStamp: string;
    userRoles: IAppUserRole[] | null;
    roleClaims: IAppRoleClaim[] | null;
}

export class AppRoleClaim implements IAppRoleClaim {
    id!: number;
    roleId!: number;
    claimType!: string | null;
    claimValue!: string | null;
    role!: AppRole;

    constructor(data?: IAppRoleClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.role = data.role && !(<any>data.role).toJSON ? new AppRole(data.role) : <AppRole>this.role;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.claimType = _data["claimType"] !== undefined ? _data["claimType"] : <any>null;
            this.claimValue = _data["claimValue"] !== undefined ? _data["claimValue"] : <any>null;
            this.role = _data["role"] ? AppRole.fromJS(_data["role"]) : <any>null;
        }
    }

    static fromJS(data: any): AppRoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new AppRoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["claimType"] = this.claimType !== undefined ? this.claimType : <any>null;
        data["claimValue"] = this.claimValue !== undefined ? this.claimValue : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data;
    }
}

export interface IAppRoleClaim {
    id: number;
    roleId: number;
    claimType: string | null;
    claimValue: string | null;
    role: IAppRole;
}

export class AppToken implements IAppToken {
    userId!: number;
    loginProvider!: string;
    name!: string;
    value!: string | null;
    deviceId!: number | null;
    created!: DateTime;
    device!: AppDevice;
    user!: AppUser;

    constructor(data?: IAppToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.device = data.device && !(<any>data.device).toJSON ? new AppDevice(data.device) : <AppDevice>this.device;
            this.user = data.user && !(<any>data.user).toJSON ? new AppUser(data.user) : <AppUser>this.user;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.loginProvider = _data["loginProvider"] !== undefined ? _data["loginProvider"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.device = _data["device"] ? AppDevice.fromJS(_data["device"]) : <any>null;
            this.user = _data["user"] ? AppUser.fromJS(_data["user"]) : <any>null;
        }
    }

    static fromJS(data: any): AppToken {
        data = typeof data === 'object' ? data : {};
        let result = new AppToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["loginProvider"] = this.loginProvider !== undefined ? this.loginProvider : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["device"] = this.device ? this.device.toJSON() : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data;
    }
}

export interface IAppToken {
    userId: number;
    loginProvider: string;
    name: string;
    value: string | null;
    deviceId: number | null;
    created: DateTime;
    device: IAppDevice;
    user: IAppUser;
}

export class AppUser implements IAppUser {
    passwordHash!: string | null;
    securityStamp!: string | null;
    concurrencyStamp!: string | null;
    phoneNumber!: string | null;
    phoneNumberConfirmed!: boolean;
    twoFactorEnabled!: boolean;
    lockoutEnd!: DateTime | null;
    lockoutEnabled!: boolean;
    accessFailedCount!: number;
    id!: number;
    userName!: string;
    usernameChanges!: UsernameChange;
    firstName!: string;
    lastName!: string | null;
    middleName!: string | null;
    normalizedUserName!: string;
    email!: string;
    normalizedEmail!: string;
    emailConfirmed!: boolean;
    description!: string | null;
    profilePhotoUrl!: string | null;
    registered!: DateTime;
    userRoles!: AppUserRole[] | null;
    userClaims!: AppUserClaim[] | null;
    tokens!: AppToken[] | null;
    articles!: Article[] | null;
    savedArticles!: SavedArticle[] | null;
    photoId!: string | null;
    photo!: Resource;

    constructor(data?: IAppUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.usernameChanges = data.usernameChanges && !(<any>data.usernameChanges).toJSON ? new UsernameChange(data.usernameChanges) : <UsernameChange>this.usernameChanges;
            if (data.userRoles) {
                this.userRoles = [];
                for (let i = 0; i < data.userRoles.length; i++) {
                    let item = data.userRoles[i];
                    this.userRoles[i] = item && !(<any>item).toJSON ? new AppUserRole(item) : <AppUserRole>item;
                }
            }
            if (data.userClaims) {
                this.userClaims = [];
                for (let i = 0; i < data.userClaims.length; i++) {
                    let item = data.userClaims[i];
                    this.userClaims[i] = item && !(<any>item).toJSON ? new AppUserClaim(item) : <AppUserClaim>item;
                }
            }
            if (data.tokens) {
                this.tokens = [];
                for (let i = 0; i < data.tokens.length; i++) {
                    let item = data.tokens[i];
                    this.tokens[i] = item && !(<any>item).toJSON ? new AppToken(item) : <AppToken>item;
                }
            }
            if (data.articles) {
                this.articles = [];
                for (let i = 0; i < data.articles.length; i++) {
                    let item = data.articles[i];
                    this.articles[i] = item && !(<any>item).toJSON ? new Article(item) : <Article>item;
                }
            }
            if (data.savedArticles) {
                this.savedArticles = [];
                for (let i = 0; i < data.savedArticles.length; i++) {
                    let item = data.savedArticles[i];
                    this.savedArticles[i] = item && !(<any>item).toJSON ? new SavedArticle(item) : <SavedArticle>item;
                }
            }
            this.photo = data.photo && !(<any>data.photo).toJSON ? new Resource(data.photo) : <Resource>this.photo;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordHash = _data["passwordHash"] !== undefined ? _data["passwordHash"] : <any>null;
            this.securityStamp = _data["securityStamp"] !== undefined ? _data["securityStamp"] : <any>null;
            this.concurrencyStamp = _data["concurrencyStamp"] !== undefined ? _data["concurrencyStamp"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"] !== undefined ? _data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = _data["twoFactorEnabled"] !== undefined ? _data["twoFactorEnabled"] : <any>null;
            this.lockoutEnd = _data["lockoutEnd"] ? DateTime.fromISO(_data["lockoutEnd"].toString()) : <any>null;
            this.lockoutEnabled = _data["lockoutEnabled"] !== undefined ? _data["lockoutEnabled"] : <any>null;
            this.accessFailedCount = _data["accessFailedCount"] !== undefined ? _data["accessFailedCount"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.usernameChanges = _data["usernameChanges"] ? UsernameChange.fromJS(_data["usernameChanges"]) : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.normalizedUserName = _data["normalizedUserName"] !== undefined ? _data["normalizedUserName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.normalizedEmail = _data["normalizedEmail"] !== undefined ? _data["normalizedEmail"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            this.registered = _data["registered"] ? DateTime.fromISO(_data["registered"].toString()) : <any>null;
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(AppUserRole.fromJS(item));
            }
            else {
                this.userRoles = <any>null;
            }
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(AppUserClaim.fromJS(item));
            }
            else {
                this.userClaims = <any>null;
            }
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(AppToken.fromJS(item));
            }
            else {
                this.tokens = <any>null;
            }
            if (Array.isArray(_data["articles"])) {
                this.articles = [] as any;
                for (let item of _data["articles"])
                    this.articles!.push(Article.fromJS(item));
            }
            else {
                this.articles = <any>null;
            }
            if (Array.isArray(_data["savedArticles"])) {
                this.savedArticles = [] as any;
                for (let item of _data["savedArticles"])
                    this.savedArticles!.push(SavedArticle.fromJS(item));
            }
            else {
                this.savedArticles = <any>null;
            }
            this.photoId = _data["photoId"] !== undefined ? _data["photoId"] : <any>null;
            this.photo = _data["photo"] ? Resource.fromJS(_data["photo"]) : <any>null;
        }
    }

    static fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["securityStamp"] = this.securityStamp !== undefined ? this.securityStamp : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toString() : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["accessFailedCount"] = this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["usernameChanges"] = this.usernameChanges ? this.usernameChanges.toJSON() : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["normalizedUserName"] = this.normalizedUserName !== undefined ? this.normalizedUserName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["normalizedEmail"] = this.normalizedEmail !== undefined ? this.normalizedEmail : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        data["registered"] = this.registered ? this.registered.toString() : <any>null;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item.toJSON());
        }
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        if (Array.isArray(this.articles)) {
            data["articles"] = [];
            for (let item of this.articles)
                data["articles"].push(item.toJSON());
        }
        if (Array.isArray(this.savedArticles)) {
            data["savedArticles"] = [];
            for (let item of this.savedArticles)
                data["savedArticles"].push(item.toJSON());
        }
        data["photoId"] = this.photoId !== undefined ? this.photoId : <any>null;
        data["photo"] = this.photo ? this.photo.toJSON() : <any>null;
        return data;
    }
}

export interface IAppUser {
    passwordHash: string | null;
    securityStamp: string | null;
    concurrencyStamp: string | null;
    phoneNumber: string | null;
    phoneNumberConfirmed: boolean;
    twoFactorEnabled: boolean;
    lockoutEnd: DateTime | null;
    lockoutEnabled: boolean;
    accessFailedCount: number;
    id: number;
    userName: string;
    usernameChanges: IUsernameChange;
    firstName: string;
    lastName: string | null;
    middleName: string | null;
    normalizedUserName: string;
    email: string;
    normalizedEmail: string;
    emailConfirmed: boolean;
    description: string | null;
    profilePhotoUrl: string | null;
    registered: DateTime;
    userRoles: IAppUserRole[] | null;
    userClaims: IAppUserClaim[] | null;
    tokens: IAppToken[] | null;
    articles: IArticle[] | null;
    savedArticles: ISavedArticle[] | null;
    photoId: string | null;
    photo: IResource;
}

export class AppUserClaim implements IAppUserClaim {
    id!: number;
    userId!: number;
    claimType!: string | null;
    claimValue!: string | null;
    user!: AppUser;

    constructor(data?: IAppUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new AppUser(data.user) : <AppUser>this.user;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.claimType = _data["claimType"] !== undefined ? _data["claimType"] : <any>null;
            this.claimValue = _data["claimValue"] !== undefined ? _data["claimValue"] : <any>null;
            this.user = _data["user"] ? AppUser.fromJS(_data["user"]) : <any>null;
        }
    }

    static fromJS(data: any): AppUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["claimType"] = this.claimType !== undefined ? this.claimType : <any>null;
        data["claimValue"] = this.claimValue !== undefined ? this.claimValue : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data;
    }
}

export interface IAppUserClaim {
    id: number;
    userId: number;
    claimType: string | null;
    claimValue: string | null;
    user: IAppUser;
}

export class AppUserRole implements IAppUserRole {
    userId!: number;
    roleId!: number;
    user!: AppUser;
    role!: AppRole;

    constructor(data?: IAppUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new AppUser(data.user) : <AppUser>this.user;
            this.role = data.role && !(<any>data.role).toJSON ? new AppRole(data.role) : <AppRole>this.role;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.user = _data["user"] ? AppUser.fromJS(_data["user"]) : <any>null;
            this.role = _data["role"] ? AppRole.fromJS(_data["role"]) : <any>null;
        }
    }

    static fromJS(data: any): AppUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new AppUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data;
    }
}

export interface IAppUserRole {
    userId: number;
    roleId: number;
    user: IAppUser;
    role: IAppRole;
}

export class Article implements IArticle {
    id!: number;
    name!: string;
    originalArticleLink!: string | null;
    rate!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    authorId!: number;
    author!: AppUser;
    localizations!: ArticleLocalization[] | null;
    images!: ArticleResource[] | null;
    tags!: ArticleTag[] | null;

    constructor(data?: IArticle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.author = data.author && !(<any>data.author).toJSON ? new AppUser(data.author) : <AppUser>this.author;
            if (data.localizations) {
                this.localizations = [];
                for (let i = 0; i < data.localizations.length; i++) {
                    let item = data.localizations[i];
                    this.localizations[i] = item && !(<any>item).toJSON ? new ArticleLocalization(item) : <ArticleLocalization>item;
                }
            }
            if (data.images) {
                this.images = [];
                for (let i = 0; i < data.images.length; i++) {
                    let item = data.images[i];
                    this.images[i] = item && !(<any>item).toJSON ? new ArticleResource(item) : <ArticleResource>item;
                }
            }
            if (data.tags) {
                this.tags = [];
                for (let i = 0; i < data.tags.length; i++) {
                    let item = data.tags[i];
                    this.tags[i] = item && !(<any>item).toJSON ? new ArticleTag(item) : <ArticleTag>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.author = _data["author"] ? AppUser.fromJS(_data["author"]) : <any>null;
            if (Array.isArray(_data["localizations"])) {
                this.localizations = [] as any;
                for (let item of _data["localizations"])
                    this.localizations!.push(ArticleLocalization.fromJS(item));
            }
            else {
                this.localizations = <any>null;
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ArticleResource.fromJS(item));
            }
            else {
                this.images = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ArticleTag.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): Article {
        data = typeof data === 'object' ? data : {};
        let result = new Article();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["author"] = this.author ? this.author.toJSON() : <any>null;
        if (Array.isArray(this.localizations)) {
            data["localizations"] = [];
            for (let item of this.localizations)
                data["localizations"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArticle {
    id: number;
    name: string;
    originalArticleLink: string | null;
    rate: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    authorId: number;
    author: IAppUser;
    localizations: IArticleLocalization[] | null;
    images: IArticleResource[] | null;
    tags: IArticleTag[] | null;
}

export class ArticleContributor implements IArticleContributor {
    id!: number;
    role!: ArticleContributorRole;
    userId!: number;
    user!: AppUser;
    localizationId!: number;
    localization!: ArticleLocalization;

    constructor(data?: IArticleContributor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new AppUser(data.user) : <AppUser>this.user;
            this.localization = data.localization && !(<any>data.localization).toJSON ? new ArticleLocalization(data.localization) : <ArticleLocalization>this.localization;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.user = _data["user"] ? AppUser.fromJS(_data["user"]) : <any>null;
            this.localizationId = _data["localizationId"] !== undefined ? _data["localizationId"] : <any>null;
            this.localization = _data["localization"] ? ArticleLocalization.fromJS(_data["localization"]) : <any>null;
        }
    }

    static fromJS(data: any): ArticleContributor {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleContributor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["localizationId"] = this.localizationId !== undefined ? this.localizationId : <any>null;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>null;
        return data;
    }
}

export interface IArticleContributor {
    id: number;
    role: ArticleContributorRole;
    userId: number;
    user: IAppUser;
    localizationId: number;
    localization: IArticleLocalization;
}

export class ArticleContributorModel implements IArticleContributorModel {
    role!: ArticleContributorRole;
    userName!: string;

    constructor(data?: IArticleContributorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleContributorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleContributorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IArticleContributorModel {
    role: ArticleContributorRole;
    userName: string;
}

export enum ArticleContributorRole {
    Author = "Author",
    Editor = "Editor",
    Test = "Test",
    Copyrighter = "Copyrighter",
    Translator = "Translator",
}

export class ArticleLocalization implements IArticleLocalization {
    id!: number;
    articleId!: number;
    article!: Article;
    languageCode!: string;
    language!: Language;
    title!: string;
    description!: string;
    html!: string;
    views!: number;
    status!: ContentStatus;
    internalStatus!: InternalStatus;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    lastContributorId!: number | null;
    lastContributor!: AppUser;
    contributors!: ArticleContributor[];

    constructor(data?: IArticleLocalization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.article = data.article && !(<any>data.article).toJSON ? new Article(data.article) : <Article>this.article;
            this.language = data.language && !(<any>data.language).toJSON ? new Language(data.language) : <Language>this.language;
            this.lastContributor = data.lastContributor && !(<any>data.lastContributor).toJSON ? new AppUser(data.lastContributor) : <AppUser>this.lastContributor;
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributor(item) : <ArticleContributor>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.article = _data["article"] ? Article.fromJS(_data["article"]) : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            this.views = _data["views"] !== undefined ? _data["views"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.internalStatus = _data["internalStatus"] !== undefined ? _data["internalStatus"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.lastContributorId = _data["lastContributorId"] !== undefined ? _data["lastContributorId"] : <any>null;
            this.lastContributor = _data["lastContributor"] ? AppUser.fromJS(_data["lastContributor"]) : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributor.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleLocalization {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["article"] = this.article ? this.article.toJSON() : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["language"] = this.language ? this.language.toJSON() : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        data["views"] = this.views !== undefined ? this.views : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["internalStatus"] = this.internalStatus !== undefined ? this.internalStatus : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["lastContributorId"] = this.lastContributorId !== undefined ? this.lastContributorId : <any>null;
        data["lastContributor"] = this.lastContributor ? this.lastContributor.toJSON() : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArticleLocalization {
    id: number;
    articleId: number;
    article: IArticle;
    languageCode: string;
    language: ILanguage;
    title: string;
    description: string;
    html: string;
    views: number;
    status: ContentStatus;
    internalStatus: InternalStatus;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    lastContributorId: number | null;
    lastContributor: IAppUser;
    contributors: IArticleContributor[];
}

export class ArticleLocalizationModel implements IArticleLocalizationModel {
    id!: number;
    articleId!: number;
    languageCode!: string;
    contributors!: ArticleContributorModel[];
    title!: string;
    description!: string;
    html!: string;
    status!: ContentStatus;
    views!: number;
    rate!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    isSaved!: boolean;
    savedDate!: DateTime | null;
    vote!: Vote;

    constructor(data?: IArticleLocalizationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.views = _data["views"] !== undefined ? _data["views"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
            this.savedDate = _data["savedDate"] ? DateTime.fromISO(_data["savedDate"].toString()) : <any>null;
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleLocalizationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["views"] = this.views !== undefined ? this.views : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        data["savedDate"] = this.savedDate ? this.savedDate.toString() : <any>null;
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IArticleLocalizationModel {
    id: number;
    articleId: number;
    languageCode: string;
    contributors: IArticleContributorModel[];
    title: string;
    description: string;
    html: string;
    status: ContentStatus;
    views: number;
    rate: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    isSaved: boolean;
    savedDate: DateTime | null;
    vote: Vote;
}

export class ArticleModel implements IArticleModel {
    id!: number;
    name!: string;
    authorId!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    originalArticleLink!: string | null;
    rate!: number;
    localizations!: ArticleLocalizationModel[] | null;
    tags!: string[];

    constructor(data?: IArticleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.localizations) {
                this.localizations = [];
                for (let i = 0; i < data.localizations.length; i++) {
                    let item = data.localizations[i];
                    this.localizations[i] = item && !(<any>item).toJSON ? new ArticleLocalizationModel(item) : <ArticleLocalizationModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            if (Array.isArray(_data["localizations"])) {
                this.localizations = [] as any;
                for (let item of _data["localizations"])
                    this.localizations!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                this.localizations = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        if (Array.isArray(this.localizations)) {
            data["localizations"] = [];
            for (let item of this.localizations)
                data["localizations"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IArticleModel {
    id: number;
    name: string;
    authorId: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    originalArticleLink: string | null;
    rate: number;
    localizations: IArticleLocalizationModel[] | null;
    tags: string[];
}

export class ArticleModelFiltered implements IArticleModelFiltered {
    total!: number;
    data!: ArticleModel[];

    constructor(data?: IArticleModelFiltered) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new ArticleModel(item) : <ArticleModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ArticleModel.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleModelFiltered {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModelFiltered();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total !== undefined ? this.total : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArticleModelFiltered {
    total: number;
    data: IArticleModel[];
}

export class ArticleResource implements IArticleResource {
    articleId!: number;
    article!: Article;
    resourceId!: string;
    resource!: Resource;

    constructor(data?: IArticleResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.article = data.article && !(<any>data.article).toJSON ? new Article(data.article) : <Article>this.article;
            this.resource = data.resource && !(<any>data.resource).toJSON ? new Resource(data.resource) : <Resource>this.resource;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.article = _data["article"] ? Article.fromJS(_data["article"]) : <any>null;
            this.resourceId = _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
            this.resource = _data["resource"] ? Resource.fromJS(_data["resource"]) : <any>null;
        }
    }

    static fromJS(data: any): ArticleResource {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["article"] = this.article ? this.article.toJSON() : <any>null;
        data["resourceId"] = this.resourceId !== undefined ? this.resourceId : <any>null;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>null;
        return data;
    }
}

export interface IArticleResource {
    articleId: number;
    article: IArticle;
    resourceId: string;
    resource: IResource;
}

export class ArticleTag implements IArticleTag {
    tagId!: number;
    tag!: Tag;
    articleId!: number;
    article!: Article;

    constructor(data?: IArticleTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.tag = data.tag && !(<any>data.tag).toJSON ? new Tag(data.tag) : <Tag>this.tag;
            this.article = data.article && !(<any>data.article).toJSON ? new Article(data.article) : <Article>this.article;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"] !== undefined ? _data["tagId"] : <any>null;
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.article = _data["article"] ? Article.fromJS(_data["article"]) : <any>null;
        }
    }

    static fromJS(data: any): ArticleTag {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId !== undefined ? this.tagId : <any>null;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["article"] = this.article ? this.article.toJSON() : <any>null;
        return data;
    }
}

export interface IArticleTag {
    tagId: number;
    tag: ITag;
    articleId: number;
    article: IArticle;
}

export class AuthRequest implements IAuthRequest {
    login!: string;
    password!: string | null;

    constructor(data?: IAuthRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"] !== undefined ? _data["login"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AuthRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login !== undefined ? this.login : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface IAuthRequest {
    login: string;
    password: string | null;
}

export class AuthResult implements IAuthResult {
    username!: string;
    firstName!: string;
    lastName!: string | null;
    token!: string;
    tokenExpires!: DateTime;
    refreshTokenExpires!: DateTime;
    profilePhotoUrl!: string | null;

    constructor(data?: IAuthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.tokenExpires = _data["tokenExpires"] ? DateTime.fromISO(_data["tokenExpires"].toString()) : <any>null;
            this.refreshTokenExpires = _data["refreshTokenExpires"] ? DateTime.fromISO(_data["refreshTokenExpires"].toString()) : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): AuthResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["tokenExpires"] = this.tokenExpires ? this.tokenExpires.toString() : <any>null;
        data["refreshTokenExpires"] = this.refreshTokenExpires ? this.refreshTokenExpires.toString() : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        return data;
    }
}

export interface IAuthResult {
    username: string;
    firstName: string;
    lastName: string | null;
    token: string;
    tokenExpires: DateTime;
    refreshTokenExpires: DateTime;
    profilePhotoUrl: string | null;
}

export enum ContentStatus {
    Draft = "Draft",
    Pending = "Pending",
    Published = "Published",
    Banned = "Banned",
}

export enum DeviceStatus {
    None = "None",
    Banned = "Banned",
}

export class ErrorDto implements IErrorDto {
    status!: number;
    type!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDto {
    status: number;
    type: string;
    message: string;

    [key: string]: any;
}

export class ErrorDetails implements IErrorDetails {
    field!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] !== undefined ? _data["field"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field !== undefined ? this.field : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDetails {
    field: string;
    message: string;

    [key: string]: any;
}

export enum InternalStatus {
    Created = "Created",
    AddedHtml = "AddedHtml",
}

export class Language implements ILanguage {
    code!: string;
    name!: string;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILanguage {
    code: string;
    name: string;
}

export class LanguageModel implements ILanguageModel {
    code!: string;
    name!: string;

    constructor(data?: ILanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILanguageModel {
    code: string;
    name: string;
}

export class LanguageModelFiltered implements ILanguageModelFiltered {
    total!: number;
    data!: LanguageModel[];

    constructor(data?: ILanguageModelFiltered) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new LanguageModel(item) : <LanguageModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LanguageModel.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): LanguageModelFiltered {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModelFiltered();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total !== undefined ? this.total : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILanguageModelFiltered {
    total: number;
    data: ILanguageModel[];
}

export class PermissionModel implements IPermissionModel {
    key!: string;
    manageKey!: string | null;
    displayName!: string;
    children!: PermissionModel[] | null;

    constructor(data?: IPermissionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.children) {
                this.children = [];
                for (let i = 0; i < data.children.length; i++) {
                    let item = data.children[i];
                    this.children[i] = item && !(<any>item).toJSON ? new PermissionModel(item) : <PermissionModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.manageKey = _data["manageKey"] !== undefined ? _data["manageKey"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(PermissionModel.fromJS(item));
            }
            else {
                this.children = <any>null;
            }
        }
    }

    static fromJS(data: any): PermissionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["manageKey"] = this.manageKey !== undefined ? this.manageKey : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionModel {
    key: string;
    manageKey: string | null;
    displayName: string;
    children: IPermissionModel[] | null;
}

export class Resource implements IResource {
    id!: string;
    filename!: string;
    mimetype!: string;
    bytes!: string;
    created!: DateTime;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.filename = _data["filename"] !== undefined ? _data["filename"] : <any>null;
            this.mimetype = _data["mimetype"] !== undefined ? _data["mimetype"] : <any>null;
            this.bytes = _data["bytes"] !== undefined ? _data["bytes"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["mimetype"] = this.mimetype !== undefined ? this.mimetype : <any>null;
        data["bytes"] = this.bytes !== undefined ? this.bytes : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        return data;
    }
}

export interface IResource {
    id: string;
    filename: string;
    mimetype: string;
    bytes: string;
    created: DateTime;
}

export class RoleModel implements IRoleModel {
    id!: number;
    name!: string;
    permissions!: string[];

    constructor(data?: IRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            else {
                this.permissions = <any>null;
            }
        }
    }

    static fromJS(data: any): RoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IRoleModel {
    id: number;
    name: string;
    permissions: string[];
}

export class RoleModelFiltered implements IRoleModelFiltered {
    total!: number;
    data!: RoleModel[];

    constructor(data?: IRoleModelFiltered) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new RoleModel(item) : <RoleModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RoleModel.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): RoleModelFiltered {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModelFiltered();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total !== undefined ? this.total : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleModelFiltered {
    total: number;
    data: IRoleModel[];
}

export class SavedArticle implements ISavedArticle {
    localizationId!: number;
    localization!: ArticleLocalization;
    userId!: number;
    user!: AppUser;
    savedDate!: DateTime;

    constructor(data?: ISavedArticle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.localization = data.localization && !(<any>data.localization).toJSON ? new ArticleLocalization(data.localization) : <ArticleLocalization>this.localization;
            this.user = data.user && !(<any>data.user).toJSON ? new AppUser(data.user) : <AppUser>this.user;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.localizationId = _data["localizationId"] !== undefined ? _data["localizationId"] : <any>null;
            this.localization = _data["localization"] ? ArticleLocalization.fromJS(_data["localization"]) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.user = _data["user"] ? AppUser.fromJS(_data["user"]) : <any>null;
            this.savedDate = _data["savedDate"] ? DateTime.fromISO(_data["savedDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SavedArticle {
        data = typeof data === 'object' ? data : {};
        let result = new SavedArticle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localizationId"] = this.localizationId !== undefined ? this.localizationId : <any>null;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["savedDate"] = this.savedDate ? this.savedDate.toString() : <any>null;
        return data;
    }
}

export interface ISavedArticle {
    localizationId: number;
    localization: IArticleLocalization;
    userId: number;
    user: IAppUser;
    savedDate: DateTime;
}

export class Tag implements ITag {
    id!: number;
    name!: string;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ITag {
    id: number;
    name: string;
}

export class UserCreateRequest implements IUserCreateRequest {
    userName!: string;
    email!: string;
    firstName!: string;
    lastName!: string;
    password!: string | null;
    description!: string | null;

    constructor(data?: IUserCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): UserCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IUserCreateRequest {
    userName: string;
    email: string;
    firstName: string;
    lastName: string;
    password: string | null;
    description: string | null;
}

export class UserModel implements IUserModel {
    id!: number;
    userName!: string;
    firstName!: string;
    lastName!: string;
    middleName!: string;
    email!: string;
    profilePhotoUrl!: string | null;
    emailConfirmed!: boolean;
    hasPassword!: boolean;
    description!: string | null;
    registered!: DateTime;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.hasPassword = _data["hasPassword"] !== undefined ? _data["hasPassword"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.registered = _data["registered"] ? DateTime.fromISO(_data["registered"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["hasPassword"] = this.hasPassword !== undefined ? this.hasPassword : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["registered"] = this.registered ? this.registered.toString() : <any>null;
        return data;
    }
}

export interface IUserModel {
    id: number;
    userName: string;
    firstName: string;
    lastName: string;
    middleName: string;
    email: string;
    profilePhotoUrl: string | null;
    emailConfirmed: boolean;
    hasPassword: boolean;
    description: string | null;
    registered: DateTime;
}

export class UserModelFiltered implements IUserModelFiltered {
    total!: number;
    data!: UserModel[];

    constructor(data?: IUserModelFiltered) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new UserModel(item) : <UserModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserModel.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): UserModelFiltered {
        data = typeof data === 'object' ? data : {};
        let result = new UserModelFiltered();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total !== undefined ? this.total : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserModelFiltered {
    total: number;
    data: IUserModel[];
}

export class UserUpdateRequest implements IUserUpdateRequest {
    id!: number;
    userName!: string;
    email!: string;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    password!: string | null;
    description!: string | null;

    constructor(data?: IUserUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): UserUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IUserUpdateRequest {
    id: number;
    userName: string;
    email: string;
    firstName: string;
    middleName: string;
    lastName: string;
    password: string | null;
    description: string | null;
}

export class UsernameChange implements IUsernameChange {
    lastTime!: DateTime | null;
    count!: number;

    constructor(data?: IUsernameChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastTime = _data["lastTime"] ? DateTime.fromISO(_data["lastTime"].toString()) : <any>null;
            this.count = _data["count"] !== undefined ? _data["count"] : <any>null;
        }
    }

    static fromJS(data: any): UsernameChange {
        data = typeof data === 'object' ? data : {};
        let result = new UsernameChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastTime"] = this.lastTime ? this.lastTime.toString() : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        return data;
    }
}

export interface IUsernameChange {
    lastTime: DateTime | null;
    count: number;
}

export class ValidationError implements IValidationError {
    status!: number;
    type!: string;
    message!: string;
    errors!: ErrorDetails;

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.errors = data.errors && !(<any>data.errors).toJSON ? new ErrorDetails(data.errors) : <ErrorDetails>this.errors;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errors = _data["errors"] ? ErrorDetails.fromJS(_data["errors"]) : <any>null;
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errors"] = this.errors ? this.errors.toJSON() : <any>null;
        return data;
    }
}

export interface IValidationError {
    status: number;
    type: string;
    message: string;
    errors: IErrorDetails;

    [key: string]: any;
}

export enum Vote {
    Up = "Up",
    Down = "Down",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}