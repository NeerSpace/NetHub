//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export class ArticleLocalizationsApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional)
     * @return Created
     */
    create(id: string, lang: string, body: ArticleLocalizationCreateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleLocalizationModel | null> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ArticleLocalizationModel | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 ? ArticleLocalizationModel.fromJS(resultData201) : <any>null;
            return Promise.resolve<ArticleLocalizationModel | null>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleLocalizationModel | null>(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number, lang: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getByIdAndCode(id: number, lang: string | null , cancelToken?: CancelToken | undefined): Promise<ArticleLocalizationModel | null> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByIdAndCode(_response);
        });
    }

    protected processGetByIdAndCode(response: AxiosResponse): Promise<ArticleLocalizationModel | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? ArticleLocalizationModel.fromJS(resultData200) : <any>null;
            return Promise.resolve<ArticleLocalizationModel | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleLocalizationModel | null>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    put(id: string, lang: string, body: ArticleLocalizationUpdateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param contributorUsername (optional)
     * @return Success
     */
    search(lang: string | null, contributorUsername: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<(ArticleLocalizationModel | null)[]> {
        let url_ = this.baseUrl + "/v1/articles/{Lang}/search?";
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{Lang}", encodeURIComponent("" + lang));
        if (contributorUsername !== undefined && contributorUsername !== null)
            url_ += "ContributorUsername=" + encodeURIComponent("" + contributorUsername) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<(ArticleLocalizationModel | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(ArticleLocalizationModel | null)[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(ArticleLocalizationModel | null)[]>(null as any);
    }

    /**
     * @param status (optional)
     * @return No Content
     */
    updateStatus(id: number, language: string | null, status: ArticleStatusActions | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{Id}/{Language}/status?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{Language}", encodeURIComponent("" + language));
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ArticlesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional)
     * @return Created
     */
    create(body: ArticleCreateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtended> {
        let url_ = this.baseUrl + "/v1/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ArticleModelExtended> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ArticleModelExtended.fromJS(resultData201);
            return Promise.resolve<ArticleModelExtended>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtended>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    update(body: ArticleUpdateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getById(id: number , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtended> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<ArticleModelExtended> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ArticleModelExtended.fromJS(resultData200);
            return Promise.resolve<ArticleModelExtended>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtended>(null as any);
    }

    /**
     * @param file (optional)
     * @return Created
     */
    uploadImage(id: number, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<AddArticleImageResult | null> {
        let url_ = this.baseUrl + "/v1/articles/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadImage(_response);
        });
    }

    protected processUploadImage(response: AxiosResponse): Promise<AddArticleImageResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 ? AddArticleImageResult.fromJS(resultData201) : <any>null;
            return Promise.resolve<AddArticleImageResult | null>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddArticleImageResult | null>(null as any);
    }
}

export class CurrencyApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<CurrenciesResponse | null> {
        let url_ = this.baseUrl + "/v1/currency-rates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CurrenciesResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? CurrenciesResponse.fromJS(resultData200) : <any>null;
            return Promise.resolve<CurrenciesResponse | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrenciesResponse | null>(null as any);
    }
}

export class CurrentUserApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    dashboard(  cancelToken?: CancelToken | undefined): Promise<DashboardResult | null> {
        let url_ = this.baseUrl + "/v1/me/dashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<DashboardResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? DashboardResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<DashboardResult | null>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardResult | null>(null as any);
    }

    /**
     * @return Success
     */
    me(  cancelToken?: CancelToken | undefined): Promise<UserResult | null> {
        let url_ = this.baseUrl + "/v1/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMe(_response);
        });
    }

    protected processMe(response: AxiosResponse): Promise<UserResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? UserResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<UserResult | null>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserResult | null>(null as any);
    }

    /**
     * @param link (optional)
     * @param file (optional)
     * @return Success
     */
    updateProfilePhoto(link: string | null | undefined, file: FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<MeProfilePhotoUpdateResult | null> {
        let url_ = this.baseUrl + "/v1/me/profile-picture?";
        if (link !== undefined && link !== null)
            url_ += "Link=" + encodeURIComponent("" + link) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProfilePhoto(_response);
        });
    }

    protected processUpdateProfilePhoto(response: AxiosResponse): Promise<MeProfilePhotoUpdateResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? MeProfilePhotoUpdateResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<MeProfilePhotoUpdateResult | null>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MeProfilePhotoUpdateResult | null>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    updateProfile(body: MeProfileUpdateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/me/profile";
        url_ = url_.replace(/[?&]$/, "");


        let options_: AxiosRequestConfig = {
            data: body,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProfile(_response);
        });
    }

    protected processUpdateProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param username (optional)
     * @return No Content
     */
    updateProfileUsername(username: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/me/profile-username?";
        if (username !== undefined && username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProfileUsername(_response);
        });
    }

    protected processUpdateProfileUsername(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class JwtApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional)
     * @return Created
     */
    authenticate(body: JwtAuthenticateRequest | null | undefined , cancelToken?: CancelToken | undefined): Promise<JwtResult | null> {
        let url_ = this.baseUrl + "/v1/jwt/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<JwtResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 ? JwtResult.fromJS(resultData201) : <any>null;
            return Promise.resolve<JwtResult | null>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JwtResult | null>(null as any);
    }

    /**
     * @return Created
     */
    refresh(  cancelToken?: CancelToken | undefined): Promise<JwtResult | null> {
        let url_ = this.baseUrl + "/v1/jwt/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<JwtResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = resultData201 ? JwtResult.fromJS(resultData201) : <any>null;
            return Promise.resolve<JwtResult | null>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JwtResult | null>(null as any);
    }

    /**
     * @return No Content
     */
    revoke(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/auth/revoke";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevoke(_response);
        });
    }

    protected processRevoke(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LanguagesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getAll(  cancelToken?: CancelToken | undefined): Promise<(LanguageModel | null)[]> {
        let url_ = this.baseUrl + "/v1/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<(LanguageModel | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(LanguageModel | null)[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(LanguageModel | null)[]>(null as any);
    }
}

export class MyArticlesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    isSaved(id: number, lang: string | null , cancelToken?: CancelToken | undefined): Promise<IsSavedLocalizationResult | null> {
        let url_ = this.baseUrl + "/v1/me/saved-articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSaved(_response);
        });
    }

    protected processIsSaved(response: AxiosResponse): Promise<IsSavedLocalizationResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? IsSavedLocalizationResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<IsSavedLocalizationResult | null>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IsSavedLocalizationResult | null>(null as any);
    }

    /**
     * @return No Content
     */
    toggleSave(id: number, lang: string | null , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/me/saved-articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleSave(_response);
        });
    }

    protected processToggleSave(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    savedArticles(  cancelToken?: CancelToken | undefined): Promise<(ArticleLocalizationModel | null)[]> {
        let url_ = this.baseUrl + "/v1/me/saved-articles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedArticles(_response);
        });
    }

    protected processSavedArticles(response: AxiosResponse): Promise<(ArticleLocalizationModel | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(ArticleLocalizationModel | null)[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(ArticleLocalizationModel | null)[]>(null as any);
    }

    /**
     * @return Success
     */
    getVote(id: number, articleId: string , cancelToken?: CancelToken | undefined): Promise<RatingModel | null> {
        let url_ = this.baseUrl + "/v1/me/articles/{articleId}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (articleId === undefined || articleId === null)
            throw new Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVote(_response);
        });
    }

    protected processGetVote(response: AxiosResponse): Promise<RatingModel | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? RatingModel.fromJS(resultData200) : <any>null;
            return Promise.resolve<RatingModel | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RatingModel | null>(null as any);
    }

    /**
     * @param vote (optional)
     * @return Created
     */
    updateVote(id: number, vote: Vote | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/me/articles/{Id}/vote?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        if (vote === null)
            throw new Error("The parameter 'vote' cannot be null.");
        else if (vote !== undefined)
            url_ += "Vote=" + encodeURIComponent("" + vote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateVote(_response);
        });
    }

    protected processUpdateVote(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ResourcesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getById(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/resources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TestApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<(ArticleLocalizationModel | null)[]> {
        let url_ = this.baseUrl + "/v1/test-extended-articles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<(ArticleLocalizationModel | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(ArticleLocalizationModel | null)[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(ArticleLocalizationModel | null)[]>(null as any);
    }
}

export class UsersApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param key (optional)
     * @param provider (optional)
     * @return Success
     */
    checkIfExists(key: string | null | undefined, provider: ProviderType | undefined , cancelToken?: CancelToken | undefined): Promise<UserCheckIfExistsResult | null> {
        let url_ = this.baseUrl + "/v1/users/check-if-exists?";
        if (key !== undefined && key !== null)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (provider === null)
            throw new Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "Provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckIfExists(_response);
        });
    }

    protected processCheckIfExists(response: AxiosResponse): Promise<UserCheckIfExistsResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? UserCheckIfExistsResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<UserCheckIfExistsResult | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserCheckIfExistsResult | null>(null as any);
    }

    /**
     * @return Success
     */
    checkUsername(username: string | null , cancelToken?: CancelToken | undefined): Promise<CheckUsernameResult | null> {
        let url_ = this.baseUrl + "/v1/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckUsername(_response);
        });
    }

    protected processCheckUsername(response: AxiosResponse): Promise<CheckUsernameResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? CheckUsernameResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<CheckUsernameResult | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckUsernameResult | null>(null as any);
    }

    /**
     * @return Success
     */
    dashboard(username: string | null , cancelToken?: CancelToken | undefined): Promise<DashboardResult | null> {
        let url_ = this.baseUrl + "/v1/users/{username}/dashboard";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<DashboardResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 ? DashboardResult.fromJS(resultData200) : <any>null;
            return Promise.resolve<DashboardResult | null>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardResult | null>(null as any);
    }

    /**
     * @param page (optional)
     * @param perPage (optional)
     * @return Success
     */
    userArticles(userName: string | null, page: number | undefined, perPage: number | undefined , cancelToken?: CancelToken | undefined): Promise<(ArticleModel | null)[]> {
        let url_ = this.baseUrl + "/v1/users/{username}/articles?";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{UserName}", encodeURIComponent("" + userName));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserArticles(_response);
        });
    }

    protected processUserArticles(response: AxiosResponse): Promise<(ArticleModel | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(ArticleModel | null)[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(ArticleModel | null)[]>(null as any);
    }

    /**
     * @param usernames (optional)
     * @return Success
     */
    usersInfo(usernames: (string | null)[] | undefined , cancelToken?: CancelToken | undefined): Promise<(PrivateUserResult | null)[]> {
        let url_ = this.baseUrl + "/v1/users/search?";
        if (usernames === null)
            throw new Error("The parameter 'usernames' cannot be null.");
        else if (usernames !== undefined)
            usernames && usernames.forEach(item => { url_ += "Usernames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUsersInfo(_response);
        });
    }

    protected processUsersInfo(response: AxiosResponse): Promise<(PrivateUserResult | null)[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrivateUserResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<(PrivateUserResult | null)[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<(PrivateUserResult | null)[]>(null as any);
    }
}

export class AddArticleImageResult implements IAddArticleImageResult {
    location!: string | null;

    constructor(data?: IAddArticleImageResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
        }
    }

    static fromJS(data: any): AddArticleImageResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddArticleImageResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location !== undefined ? this.location : <any>null;
        return data;
    }
}

export interface IAddArticleImageResult {
    location: string | null;
}

export class ArticleContributorModel implements IArticleContributorModel {
    role!: ArticleContributorRole;
    userName!: string | null;
    profilePhotoUrl!: string | null;

    constructor(data?: IArticleContributorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleContributorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleContributorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        return data;
    }
}

export interface IArticleContributorModel {
    role: ArticleContributorRole;
    userName: string | null;
    profilePhotoUrl: string | null;
}

export enum ArticleContributorRole {
    Author = "Author",
    Editor = "Editor",
    Test = "Test",
    Copyrighter = "Copyrighter",
    Translator = "Translator",
}

export class ArticleCreateRequest implements IArticleCreateRequest {
    name!: string | null;
    tags!: (string | null)[] | null;
    originalArticleLink!: string | null;

    constructor(data?: IArticleCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        return data;
    }
}

export interface IArticleCreateRequest {
    name: string | null;
    tags: (string | null)[] | null;
    originalArticleLink: string | null;
}

export class ArticleLocalizationCreateRequest implements IArticleLocalizationCreateRequest {
    id!: number;
    languageCode!: string | null;
    title!: string | null;
    description!: string | null;
    html!: string | null;
    contributors!: (ArticleContributorModel | null)[] | null;

    constructor(data?: IArticleLocalizationCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleLocalizationCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArticleLocalizationCreateRequest {
    id: number;
    languageCode: string | null;
    title: string | null;
    description: string | null;
    html: string | null;
    contributors: (IArticleContributorModel | null)[] | null;
}

export class ArticleLocalizationModel implements IArticleLocalizationModel {
    id!: number;
    articleId!: number;
    languageCode!: string | null;
    contributors!: (ArticleContributorModel | null)[];
    title!: string | null;
    description!: string | null;
    html!: string | null;
    status!: ContentStatus;
    views!: number;
    rate!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    isSaved!: boolean;
    savedDate!: DateTime | null;
    vote!: Vote | null;

    constructor(data?: IArticleLocalizationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.views = _data["views"] !== undefined ? _data["views"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
            this.savedDate = _data["savedDate"] ? DateTime.fromISO(_data["savedDate"].toString()) : <any>null;
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleLocalizationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["views"] = this.views !== undefined ? this.views : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        data["savedDate"] = this.savedDate ? this.savedDate.toString() : <any>null;
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IArticleLocalizationModel {
    id: number;
    articleId: number;
    languageCode: string | null;
    contributors: (IArticleContributorModel | null)[];
    title: string | null;
    description: string | null;
    html: string | null;
    status: ContentStatus;
    views: number;
    rate: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    isSaved: boolean;
    savedDate: DateTime | null;
    vote: Vote | null;
}

export class ArticleLocalizationUpdateRequest implements IArticleLocalizationUpdateRequest {
    id!: number;
    languageCode!: string | null;
    newLanguageCode!: string | null;
    title!: string | null;
    description!: string | null;
    html!: string | null;
    contributors!: (ArticleContributorModel | null)[] | null;

    constructor(data?: IArticleLocalizationUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.newLanguageCode = _data["newLanguageCode"] !== undefined ? _data["newLanguageCode"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleLocalizationUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["newLanguageCode"] = this.newLanguageCode !== undefined ? this.newLanguageCode : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IArticleLocalizationUpdateRequest {
    id: number;
    languageCode: string | null;
    newLanguageCode: string | null;
    title: string | null;
    description: string | null;
    html: string | null;
    contributors: (IArticleContributorModel | null)[] | null;
}

export class ArticleModel implements IArticleModel {
    id!: number;
    name!: string | null;
    authorId!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    originalArticleLink!: string | null;
    rate!: number;
    localizations!: (ArticleLocalizationModel | null)[] | null;
    tags!: (string | null)[];

    constructor(data?: IArticleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.localizations) {
                this.localizations = [];
                for (let i = 0; i < data.localizations.length; i++) {
                    let item = data.localizations[i];
                    this.localizations[i] = item && !(<any>item).toJSON ? new ArticleLocalizationModel(item) : <ArticleLocalizationModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            if (Array.isArray(_data["localizations"])) {
                this.localizations = [] as any;
                for (let item of _data["localizations"])
                    this.localizations!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                this.localizations = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        if (Array.isArray(this.localizations)) {
            data["localizations"] = [];
            for (let item of this.localizations)
                data["localizations"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IArticleModel {
    id: number;
    name: string | null;
    authorId: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    originalArticleLink: string | null;
    rate: number;
    localizations: (IArticleLocalizationModel | null)[] | null;
    tags: (string | null)[];
}

export class ArticleModelExtended implements IArticleModelExtended {
    id!: number;
    name!: string | null;
    authorId!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    originalArticleLink!: string | null;
    rate!: number;
    localizations!: (ArticleLocalizationModel | null)[] | null;
    tags!: (string | null)[];
    imagesLinks!: (string | null)[] | null;

    constructor(data?: IArticleModelExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.localizations) {
                this.localizations = [];
                for (let i = 0; i < data.localizations.length; i++) {
                    let item = data.localizations[i];
                    this.localizations[i] = item && !(<any>item).toJSON ? new ArticleLocalizationModel(item) : <ArticleLocalizationModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            if (Array.isArray(_data["localizations"])) {
                this.localizations = [] as any;
                for (let item of _data["localizations"])
                    this.localizations!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                this.localizations = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            if (Array.isArray(_data["imagesLinks"])) {
                this.imagesLinks = [] as any;
                for (let item of _data["imagesLinks"])
                    this.imagesLinks!.push(item);
            }
            else {
                this.imagesLinks = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleModelExtended {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModelExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        if (Array.isArray(this.localizations)) {
            data["localizations"] = [];
            for (let item of this.localizations)
                data["localizations"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.imagesLinks)) {
            data["imagesLinks"] = [];
            for (let item of this.imagesLinks)
                data["imagesLinks"].push(item);
        }
        return data;
    }
}

export interface IArticleModelExtended {
    id: number;
    name: string | null;
    authorId: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    originalArticleLink: string | null;
    rate: number;
    localizations: (IArticleLocalizationModel | null)[] | null;
    tags: (string | null)[];
    imagesLinks: (string | null)[] | null;
}

export enum ArticleStatusActions {
    Publish = "Publish",
    UnPublish = "UnPublish",
}

export class ArticleUpdateRequest implements IArticleUpdateRequest {
    id!: number;
    name!: string | null;
    authorId!: number | null;
    originalArticleLink!: string | null;

    constructor(data?: IArticleUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        return data;
    }
}

export interface IArticleUpdateRequest {
    id: number;
    name: string | null;
    authorId: number | null;
    originalArticleLink: string | null;
}

export class CheckUsernameResult implements ICheckUsernameResult {
    isAvailable!: boolean;

    constructor(data?: ICheckUsernameResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUsernameResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUsernameResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface ICheckUsernameResult {
    isAvailable: boolean;
}

export enum ContentStatus {
    Draft = "Draft",
    Pending = "Pending",
    Published = "Published",
    Banned = "Banned",
}

export class CryptoResponseDto implements ICryptoResponseDto {
    btc!: OneCryptoDto;
    ton!: OneCryptoDto;
    error!: string | null;

    constructor(data?: ICryptoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.btc = data.btc && !(<any>data.btc).toJSON ? new OneCryptoDto(data.btc) : <OneCryptoDto>this.btc;
            this.ton = data.ton && !(<any>data.ton).toJSON ? new OneCryptoDto(data.ton) : <OneCryptoDto>this.ton;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.btc = _data["btc"] ? OneCryptoDto.fromJS(_data["btc"]) : <any>null;
            this.ton = _data["ton"] ? OneCryptoDto.fromJS(_data["ton"]) : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
        }
    }

    static fromJS(data: any): CryptoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["btc"] = this.btc ? this.btc.toJSON() : <any>null;
        data["ton"] = this.ton ? this.ton.toJSON() : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data;
    }
}

export interface ICryptoResponseDto {
    btc: IOneCryptoDto;
    ton: IOneCryptoDto;
    error: string | null;
}

export class CurrenciesResponse implements ICurrenciesResponse {
    exchanges!: ExchangeResponseModel | null;
    crypto!: CryptoResponseDto | null;
    updated!: DateTime;

    constructor(data?: ICurrenciesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.exchanges = data.exchanges && !(<any>data.exchanges).toJSON ? new ExchangeResponseModel(data.exchanges) : <ExchangeResponseModel>this.exchanges;
            this.crypto = data.crypto && !(<any>data.crypto).toJSON ? new CryptoResponseDto(data.crypto) : <CryptoResponseDto>this.crypto;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchanges = _data["exchanges"] ? ExchangeResponseModel.fromJS(_data["exchanges"]) : <any>null;
            this.crypto = _data["crypto"] ? CryptoResponseDto.fromJS(_data["crypto"]) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CurrenciesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrenciesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchanges"] = this.exchanges ? this.exchanges.toJSON() : <any>null;
        data["crypto"] = this.crypto ? this.crypto.toJSON() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        return data;
    }
}

export interface ICurrenciesResponse {
    exchanges: IExchangeResponseModel | null;
    crypto: ICryptoResponseDto | null;
    updated: DateTime;
}

export class DashboardResult implements IDashboardResult {
    articlesCount!: number;
    articlesViews!: number;

    constructor(data?: IDashboardResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articlesCount = _data["articlesCount"] !== undefined ? _data["articlesCount"] : <any>null;
            this.articlesViews = _data["articlesViews"] !== undefined ? _data["articlesViews"] : <any>null;
        }
    }

    static fromJS(data: any): DashboardResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articlesCount"] = this.articlesCount !== undefined ? this.articlesCount : <any>null;
        data["articlesViews"] = this.articlesViews !== undefined ? this.articlesViews : <any>null;
        return data;
    }
}

export interface IDashboardResult {
    articlesCount: number;
    articlesViews: number;
}

export class ErrorDto implements IErrorDto {
    status!: number;
    type!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDto {
    status: number;
    type: string;
    message: string;

    [key: string]: any;
}

export class ErrorDetails implements IErrorDetails {
    field!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] !== undefined ? _data["field"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field !== undefined ? this.field : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDetails {
    field: string;
    message: string;

    [key: string]: any;
}

export class ExchangeResponseModel implements IExchangeResponseModel {
    usd!: OneExchangeModel | null;
    euro!: OneExchangeModel | null;
    error!: string | null;

    constructor(data?: IExchangeResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.usd = data.usd && !(<any>data.usd).toJSON ? new OneExchangeModel(data.usd) : <OneExchangeModel>this.usd;
            this.euro = data.euro && !(<any>data.euro).toJSON ? new OneExchangeModel(data.euro) : <OneExchangeModel>this.euro;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usd = _data["usd"] ? OneExchangeModel.fromJS(_data["usd"]) : <any>null;
            this.euro = _data["euro"] ? OneExchangeModel.fromJS(_data["euro"]) : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
        }
    }

    static fromJS(data: any): ExchangeResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usd"] = this.usd ? this.usd.toJSON() : <any>null;
        data["euro"] = this.euro ? this.euro.toJSON() : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data;
    }
}

export interface IExchangeResponseModel {
    usd: IOneExchangeModel | null;
    euro: IOneExchangeModel | null;
    error: string | null;
}

export class IsSavedLocalizationResult implements IIsSavedLocalizationResult {
    isSaved!: boolean;

    constructor(data?: IIsSavedLocalizationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
        }
    }

    static fromJS(data: any): IsSavedLocalizationResult {
        data = typeof data === 'object' ? data : {};
        let result = new IsSavedLocalizationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        return data;
    }
}

export interface IIsSavedLocalizationResult {
    isSaved: boolean;
}

export class JwtAuthenticateRequest implements IJwtAuthenticateRequest {
    username!: string | null;
    email!: string | null;
    firstName!: string | null;
    lastName!: string | null;
    middleName!: string | null;
    profilePhotoUrl!: string | null;
    providerMetadata!: { [key: string]: string; } | null;
    provider!: ProviderType;
    providerKey!: string | null;
    type!: SsoType;

    constructor(data?: IJwtAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            if (_data["providerMetadata"]) {
                this.providerMetadata = {} as any;
                for (let key in _data["providerMetadata"]) {
                    if (_data["providerMetadata"].hasOwnProperty(key))
                        (<any>this.providerMetadata)![key] = _data["providerMetadata"][key] !== undefined ? _data["providerMetadata"][key] : <any>null;
                }
            }
            else {
                this.providerMetadata = <any>null;
            }
            this.provider = _data["provider"] !== undefined ? _data["provider"] : <any>null;
            this.providerKey = _data["providerKey"] !== undefined ? _data["providerKey"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): JwtAuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JwtAuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        if (this.providerMetadata) {
            data["providerMetadata"] = {};
            for (let key in this.providerMetadata) {
                if (this.providerMetadata.hasOwnProperty(key))
                    (<any>data["providerMetadata"])[key] = this.providerMetadata[key] !== undefined ? this.providerMetadata[key] : <any>null;
            }
        }
        data["provider"] = this.provider !== undefined ? this.provider : <any>null;
        data["providerKey"] = this.providerKey !== undefined ? this.providerKey : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

export interface IJwtAuthenticateRequest {
    username: string | null;
    email: string | null;
    firstName: string | null;
    lastName: string | null;
    middleName: string | null;
    profilePhotoUrl: string | null;
    providerMetadata: { [key: string]: string; } | null;
    provider: ProviderType;
    providerKey: string | null;
    type: SsoType;
}

export class JwtResult implements IJwtResult {
    username!: string | null;
    firstName!: string | null;
    lastName!: string | null;
    token!: string | null;
    tokenExpires!: DateTime;
    refreshTokenExpires!: DateTime;
    profilePhotoUrl!: string | null;

    constructor(data?: IJwtResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.tokenExpires = _data["tokenExpires"] ? DateTime.fromISO(_data["tokenExpires"].toString()) : <any>null;
            this.refreshTokenExpires = _data["refreshTokenExpires"] ? DateTime.fromISO(_data["refreshTokenExpires"].toString()) : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): JwtResult {
        data = typeof data === 'object' ? data : {};
        let result = new JwtResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["tokenExpires"] = this.tokenExpires ? this.tokenExpires.toString() : <any>null;
        data["refreshTokenExpires"] = this.refreshTokenExpires ? this.refreshTokenExpires.toString() : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        return data;
    }
}

export interface IJwtResult {
    username: string | null;
    firstName: string | null;
    lastName: string | null;
    token: string | null;
    tokenExpires: DateTime;
    refreshTokenExpires: DateTime;
    profilePhotoUrl: string | null;
}

export class LanguageModel implements ILanguageModel {
    code!: string | null;
    name!: string | null;

    constructor(data?: ILanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILanguageModel {
    code: string | null;
    name: string | null;
}

export class MeProfilePhotoUpdateResult implements IMeProfilePhotoUpdateResult {
    link!: string | null;

    constructor(data?: IMeProfilePhotoUpdateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.link = _data["link"] !== undefined ? _data["link"] : <any>null;
        }
    }

    static fromJS(data: any): MeProfilePhotoUpdateResult {
        data = typeof data === 'object' ? data : {};
        let result = new MeProfilePhotoUpdateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["link"] = this.link !== undefined ? this.link : <any>null;
        return data;
    }
}

export interface IMeProfilePhotoUpdateResult {
    link: string | null;
}

export class MeProfileUpdateRequest implements IMeProfileUpdateRequest {
    firstName!: string | null;
    lastName!: string | null;
    middleName!: string | null;
    description!: string | null;

    constructor(data?: IMeProfileUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): MeProfileUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MeProfileUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IMeProfileUpdateRequest {
    firstName: string | null;
    lastName: string | null;
    middleName: string | null;
    description: string | null;
}

export class OneCryptoDto implements IOneCryptoDto {
    usd!: number;
    usd24Change!: number;
    uah!: number;
    uah24Change!: number;

    constructor(data?: IOneCryptoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usd = _data["usd"] !== undefined ? _data["usd"] : <any>null;
            this.usd24Change = _data["usd24Change"] !== undefined ? _data["usd24Change"] : <any>null;
            this.uah = _data["uah"] !== undefined ? _data["uah"] : <any>null;
            this.uah24Change = _data["uah24Change"] !== undefined ? _data["uah24Change"] : <any>null;
        }
    }

    static fromJS(data: any): OneCryptoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneCryptoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usd"] = this.usd !== undefined ? this.usd : <any>null;
        data["usd24Change"] = this.usd24Change !== undefined ? this.usd24Change : <any>null;
        data["uah"] = this.uah !== undefined ? this.uah : <any>null;
        data["uah24Change"] = this.uah24Change !== undefined ? this.uah24Change : <any>null;
        return data;
    }
}

export interface IOneCryptoDto {
    usd: number;
    usd24Change: number;
    uah: number;
    uah24Change: number;
}

export class OneExchangeModel implements IOneExchangeModel {
    currencyFrom!: string | null;
    currencyTo!: string | null;
    date!: number;
    rateBuy!: number;
    rateSell!: number;

    constructor(data?: IOneExchangeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyFrom = _data["currencyFrom"] !== undefined ? _data["currencyFrom"] : <any>null;
            this.currencyTo = _data["currencyTo"] !== undefined ? _data["currencyTo"] : <any>null;
            this.date = _data["date"] !== undefined ? _data["date"] : <any>null;
            this.rateBuy = _data["rateBuy"] !== undefined ? _data["rateBuy"] : <any>null;
            this.rateSell = _data["rateSell"] !== undefined ? _data["rateSell"] : <any>null;
        }
    }

    static fromJS(data: any): OneExchangeModel {
        data = typeof data === 'object' ? data : {};
        let result = new OneExchangeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyFrom"] = this.currencyFrom !== undefined ? this.currencyFrom : <any>null;
        data["currencyTo"] = this.currencyTo !== undefined ? this.currencyTo : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["rateBuy"] = this.rateBuy !== undefined ? this.rateBuy : <any>null;
        data["rateSell"] = this.rateSell !== undefined ? this.rateSell : <any>null;
        return data;
    }
}

export interface IOneExchangeModel {
    currencyFrom: string | null;
    currencyTo: string | null;
    date: number;
    rateBuy: number;
    rateSell: number;
}

export class PrivateUserResult implements IPrivateUserResult {
    id!: number;
    userName!: string | null;
    description!: string | null;
    profilePhotoUrl!: string | null;
    registered!: DateTime;

    constructor(data?: IPrivateUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            this.registered = _data["registered"] ? DateTime.fromISO(_data["registered"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PrivateUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        data["registered"] = this.registered ? this.registered.toString() : <any>null;
        return data;
    }
}

export interface IPrivateUserResult {
    id: number;
    userName: string | null;
    description: string | null;
    profilePhotoUrl: string | null;
    registered: DateTime;
}

export enum ProviderType {
    Telegram = "Telegram",
    Google = "Google",
    GitHub = "GitHub",
    LinkedIn = "LinkedIn",
    Facebook = "Facebook",
}

export class RatingModel implements IRatingModel {
    vote!: Vote | null;

    constructor(data?: IRatingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): RatingModel {
        data = typeof data === 'object' ? data : {};
        let result = new RatingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IRatingModel {
    vote: Vote | null;
}

export enum SsoType {
    Register = "Register",
    Login = "Login",
}

export class UserCheckIfExistsResult implements IUserCheckIfExistsResult {
    isProviderRegistered!: boolean;

    constructor(data?: IUserCheckIfExistsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isProviderRegistered = _data["isProviderRegistered"] !== undefined ? _data["isProviderRegistered"] : <any>null;
        }
    }

    static fromJS(data: any): UserCheckIfExistsResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserCheckIfExistsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isProviderRegistered"] = this.isProviderRegistered !== undefined ? this.isProviderRegistered : <any>null;
        return data;
    }
}

export interface IUserCheckIfExistsResult {
    isProviderRegistered: boolean;
}

export class UserResult implements IUserResult {
    id!: number;
    userName!: string | null;
    firstName!: string | null;
    lastName!: string | null;
    middleName!: string | null;
    email!: string | null;
    profilePhotoUrl!: string | null;
    emailConfirmed!: boolean;
    description!: string | null;
    registered!: DateTime;

    constructor(data?: IUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.registered = _data["registered"] ? DateTime.fromISO(_data["registered"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["registered"] = this.registered ? this.registered.toString() : <any>null;
        return data;
    }
}

export interface IUserResult {
    id: number;
    userName: string | null;
    firstName: string | null;
    lastName: string | null;
    middleName: string | null;
    email: string | null;
    profilePhotoUrl: string | null;
    emailConfirmed: boolean;
    description: string | null;
    registered: DateTime;
}

export class ValidationError implements IValidationError {
    status!: number;
    type!: string;
    message!: string;
    errors!: ErrorDetails;

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.errors = data.errors && !(<any>data.errors).toJSON ? new ErrorDetails(data.errors) : <ErrorDetails>this.errors;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errors = _data["errors"] ? ErrorDetails.fromJS(_data["errors"]) : <any>null;
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errors"] = this.errors ? this.errors.toJSON() : <any>null;
        return data;
    }
}

export interface IValidationError {
    status: number;
    type: string;
    message: string;
    errors: IErrorDetails;

    [key: string]: any;
}

export enum Vote {
    Up = "Up",
    Down = "Down",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

// @ts-nocheck