//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { DateTime, Duration } from "luxon";

export class ArticleLocalizationsApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Created
     */
    post(id: string, lang: string, body: CreateArticleLocalizationRequest | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleLocalizationModel> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: AxiosResponse): Promise<ArticleLocalizationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ArticleLocalizationModel.fromJS(resultData201);
            return Promise.resolve<ArticleLocalizationModel>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleLocalizationModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    delete(id: string, lang: string, body: ArticleLocalizationQuery | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    get(id: string, lang: string, body: ArticleLocalizationQuery | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleLocalizationModel> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ArticleLocalizationModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ArticleLocalizationModel.fromJS(resultData200);
            return Promise.resolve<ArticleLocalizationModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleLocalizationModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    put(id: string, lang: string, body: UpdateArticleLocalizationRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(lang: string, body: ArticleLocalizationFilter | undefined , cancelToken?: CancelToken | undefined): Promise<ViewLocalizationModel[]> {
        let url_ = this.baseUrl + "/v1/articles/{lang}/search";
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<ViewLocalizationModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViewLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ViewLocalizationModel[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ViewLocalizationModel[]>(null as any);
    }

    /**
     * @param languageCode (optional) 
     * @param page (optional) 
     * @param perPage (optional) 
     * @return Success
     */
    getAll(languageCode: string | undefined, page: number | undefined, perPage: number | undefined, lang: string , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtended[]> {
        let url_ = this.baseUrl + "/v1/articles/{lang}?";
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        if (languageCode === null)
            throw new Error("The parameter 'languageCode' cannot be null.");
        else if (languageCode !== undefined)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "PerPage=" + encodeURIComponent("" + perPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ArticleModelExtended[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleModelExtended.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ArticleModelExtended[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtended[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    status(id: string, lang: string, body: SetArticleStatusRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/{lang}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ArticlesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Created
     */
    create(body: CreateArticleRequest | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtended> {
        let url_ = this.baseUrl + "/v1/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ArticleModelExtended> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ArticleModelExtended.fromJS(resultData201);
            return Promise.resolve<ArticleModelExtended>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtended>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    update(body: UpdateArticleRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    delete(id: number , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    get(id: number , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtendedGuidArrayValueTuple> {
        let url_ = this.baseUrl + "/v1/articles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ArticleModelExtendedGuidArrayValueTuple> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ArticleModelExtendedGuidArrayValueTuple.fromJS(resultData200);
            return Promise.resolve<ArticleModelExtendedGuidArrayValueTuple>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtendedGuidArrayValueTuple>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    images(id: string, body: AddArticleImageRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImages(_response);
        });
    }

    protected processImages(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    rateGET(id: number, articleId: string , cancelToken?: CancelToken | undefined): Promise<RatingModel> {
        let url_ = this.baseUrl + "/v1/articles/{articleId}/rate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (articleId === undefined || articleId === null)
            throw new Error("The parameter 'articleId' must be defined.");
        url_ = url_.replace("{articleId}", encodeURIComponent("" + articleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRateGET(_response);
        });
    }

    protected processRateGET(response: AxiosResponse): Promise<RatingModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RatingModel.fromJS(resultData200);
            return Promise.resolve<RatingModel>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RatingModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    ratePOST(id: string, body: RateArticleRequest | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/articles/{id}/rate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRatePOST(_response);
        });
    }

    protected processRatePOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CurrencyApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<CurrenciesResponse> {
        let url_ = this.baseUrl + "/v1/currency-rates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CurrenciesResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CurrenciesResponse.fromJS(resultData200);
            return Promise.resolve<CurrenciesResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CurrenciesResponse>(null as any);
    }
}

export class CurrentUserApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    dashboard(  cancelToken?: CancelToken | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/v1/me/dashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardDto.fromJS(resultData200);
            return Promise.resolve<DashboardDto>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardDto>(null as any);
    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/v1/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param file (optional) 
     * @param link (optional) 
     * @return Created
     */
    profile(file: FileParameter | undefined, link: string | undefined , cancelToken?: CancelToken | undefined): Promise<SetUserPhotoResult> {
        let url_ = this.baseUrl + "/v1/me/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (link === null || link === undefined)
            throw new Error("The parameter 'link' cannot be null.");
        else
            content_.append("Link", link.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: AxiosResponse): Promise<SetUserPhotoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = SetUserPhotoResult.fromJS(resultData201);
            return Promise.resolve<SetUserPhotoResult>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SetUserPhotoResult>(null as any);
    }

    /**
     * @param file (optional) 
     * @param link (optional) 
     * @return Created
     */
    profilePicture(file: FileParameter | undefined, link: string | undefined , cancelToken?: CancelToken | undefined): Promise<SetUserPhotoResult> {
        let url_ = this.baseUrl + "/v1/me/profile-picture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (link === null || link === undefined)
            throw new Error("The parameter 'link' cannot be null.");
        else
            content_.append("Link", link.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProfilePicture(_response);
        });
    }

    protected processProfilePicture(response: AxiosResponse): Promise<SetUserPhotoResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = SetUserPhotoResult.fromJS(resultData201);
            return Promise.resolve<SetUserPhotoResult>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SetUserPhotoResult>(null as any);
    }
}

export class JwtApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Created
     */
    authenticate(body: SsoEnterRequest | undefined , cancelToken?: CancelToken | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/v1/jwt/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = AuthResult.fromJS(resultData201);
            return Promise.resolve<AuthResult>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * @return Created
     */
    refresh(  cancelToken?: CancelToken | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/v1/jwt/refresh";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: AxiosResponse): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = AuthResult.fromJS(resultData201);
            return Promise.resolve<AuthResult>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * @return No Content
     */
    revokeToken(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/auth/revoke-token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRevokeToken(_response);
        });
    }

    protected processRevokeToken(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LanguagesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(  cancelToken?: CancelToken | undefined): Promise<LanguageModel[]> {
        let url_ = this.baseUrl + "/v1/languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<LanguageModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageModel[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageModel[]>(null as any);
    }
}

export class ResourcesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    get(id: string , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/resources/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserSavedArticlesApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savedArticlesGET(id: string, lang: string, body: ArticleLocalizationQuery | undefined , cancelToken?: CancelToken | undefined): Promise<GetLocalizationSavingResult> {
        let url_ = this.baseUrl + "/v1/me/saved-articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedArticlesGET(_response);
        });
    }

    protected processSavedArticlesGET(response: AxiosResponse): Promise<GetLocalizationSavingResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetLocalizationSavingResult.fromJS(resultData200);
            return Promise.resolve<GetLocalizationSavingResult>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetLocalizationSavingResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    savedArticlesPATCH(id: string, lang: string, body: ArticleLocalizationQuery | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/v1/me/saved-articles/{id}/{lang}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (lang === undefined || lang === null)
            throw new Error("The parameter 'lang' must be defined.");
        url_ = url_.replace("{lang}", encodeURIComponent("" + lang));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedArticlesPATCH(_response);
        });
    }

    protected processSavedArticlesPATCH(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savedArticlesAll(body: ArticleLocalizationQuery | undefined , cancelToken?: CancelToken | undefined): Promise<ViewLocalizationModel[]> {
        let url_ = this.baseUrl + "/v1/me/saved-articles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSavedArticlesAll(_response);
        });
    }

    protected processSavedArticlesAll(response: AxiosResponse): Promise<ViewLocalizationModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViewLocalizationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ViewLocalizationModel[]>(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ViewLocalizationModel[]>(null as any);
    }
}

export class UsersApi {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param key (optional) 
     * @param provider (optional) 
     * @return Success
     */
    checkExists(key: string | undefined, provider: ProviderType | undefined , cancelToken?: CancelToken | undefined): Promise<CheckUserExistsResult> {
        let url_ = this.baseUrl + "/v1/users/check-exists?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (provider === null)
            throw new Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "Provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckExists(_response);
        });
    }

    protected processCheckExists(response: AxiosResponse): Promise<CheckUserExistsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckUserExistsResult.fromJS(resultData200);
            return Promise.resolve<CheckUserExistsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckUserExistsResult>(null as any);
    }

    /**
     * @return Success
     */
    get(username: string , cancelToken?: CancelToken | undefined): Promise<CheckUsernameResult> {
        let url_ = this.baseUrl + "/v1/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<CheckUsernameResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckUsernameResult.fromJS(resultData200);
            return Promise.resolve<CheckUsernameResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckUsernameResult>(null as any);
    }

    /**
     * @return Success
     */
    dashboard(username: string , cancelToken?: CancelToken | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/v1/users/{username}/dashboard";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardDto.fromJS(resultData200);
            return Promise.resolve<DashboardDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    articles(username: string, body: GetUserArticlesRequest | undefined , cancelToken?: CancelToken | undefined): Promise<ArticleModelExtended[]> {
        let url_ = this.baseUrl + "/v1/users/{username}/articles";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processArticles(_response);
        });
    }

    protected processArticles(response: AxiosResponse): Promise<ArticleModelExtended[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ArticleModelExtended.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ArticleModelExtended[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ArticleModelExtended[]>(null as any);
    }

    /**
     * @param userNames (optional) 
     * @return Success
     */
    getAll(userNames: string[] | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/v1/users?";
        if (userNames === null)
            throw new Error("The parameter 'userNames' cannot be null.");
        else if (userNames !== undefined)
            userNames && userNames.forEach(item => { url_ += "UserNames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: SearchUsersRequest | undefined , cancelToken?: CancelToken | undefined): Promise<PrivateUserDto[]> {
        let url_ = this.baseUrl + "/v1/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<PrivateUserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PrivateUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PrivateUserDto[]>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Validation Failed", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ValidationError.fromJS(resultData401);
            return throwException("Not Authorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Permission Denied", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PrivateUserDto[]>(null as any);
    }
}

export class AddArticleImageRequest implements IAddArticleImageRequest {
    file!: string;
    id!: number;

    constructor(data?: IAddArticleImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"] !== undefined ? _data["file"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): AddArticleImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddArticleImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file !== undefined ? this.file : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data;
    }
}

export interface IAddArticleImageRequest {
    file: string;
    id: number;
}

export class ArticleContributorModel implements IArticleContributorModel {
    role!: ArticleContributorRole;
    userName!: string;

    constructor(data?: IArticleContributorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleContributorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleContributorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data;
    }
}

export interface IArticleContributorModel {
    role: ArticleContributorRole;
    userName: string;
}

export enum ArticleContributorRole {
    Author = "Author",
    Editor = "Editor",
    Test = "Test",
    Copyrighter = "Copyrighter",
    Translator = "Translator",
}

export class ArticleLocalizationFilter implements IArticleLocalizationFilter {
    filters!: string | null;
    sorts!: string;
    page!: number;
    pageSize!: number;
    languageCode!: string;

    constructor(data?: IArticleLocalizationFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"] !== undefined ? _data["filters"] : <any>null;
            this.sorts = _data["sorts"] !== undefined ? _data["sorts"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleLocalizationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters !== undefined ? this.filters : <any>null;
        data["sorts"] = this.sorts !== undefined ? this.sorts : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        return data;
    }
}

export interface IArticleLocalizationFilter {
    filters: string | null;
    sorts: string;
    page: number;
    pageSize: number;
    languageCode: string;
}

export class ArticleLocalizationModel implements IArticleLocalizationModel {
    id!: number;
    articleId!: number;
    languageCode!: string;
    contributors!: ArticleContributorModel[];
    title!: string;
    description!: string;
    html!: string;
    status!: ContentStatus;
    views!: number;
    rate!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    isSaved!: boolean;
    savedDate!: DateTime | null;
    vote!: Vote;

    constructor(data?: IArticleLocalizationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.views = _data["views"] !== undefined ? _data["views"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
            this.savedDate = _data["savedDate"] ? DateTime.fromISO(_data["savedDate"].toString()) : <any>null;
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleLocalizationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["views"] = this.views !== undefined ? this.views : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        data["savedDate"] = this.savedDate ? this.savedDate.toString() : <any>null;
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IArticleLocalizationModel {
    id: number;
    articleId: number;
    languageCode: string;
    contributors: IArticleContributorModel[];
    title: string;
    description: string;
    html: string;
    status: ContentStatus;
    views: number;
    rate: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    isSaved: boolean;
    savedDate: DateTime | null;
    vote: Vote;
}

export class ArticleLocalizationQuery implements IArticleLocalizationQuery {
    id!: number;
    languageCode!: string;

    constructor(data?: IArticleLocalizationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
        }
    }

    static fromJS(data: any): ArticleLocalizationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleLocalizationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        return data;
    }
}

export interface IArticleLocalizationQuery {
    id: number;
    languageCode: string;
}

export class ArticleModelExtended implements IArticleModelExtended {
    id!: number;
    name!: string;
    authorId!: number;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    originalArticleLink!: string | null;
    rate!: number;
    localizations!: ArticleLocalizationModel[] | null;
    tags!: string[];
    imagesLinks!: string[] | null;

    constructor(data?: IArticleModelExtended) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.localizations) {
                this.localizations = [];
                for (let i = 0; i < data.localizations.length; i++) {
                    let item = data.localizations[i];
                    this.localizations[i] = item && !(<any>item).toJSON ? new ArticleLocalizationModel(item) : <ArticleLocalizationModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
            if (Array.isArray(_data["localizations"])) {
                this.localizations = [] as any;
                for (let item of _data["localizations"])
                    this.localizations!.push(ArticleLocalizationModel.fromJS(item));
            }
            else {
                this.localizations = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            if (Array.isArray(_data["imagesLinks"])) {
                this.imagesLinks = [] as any;
                for (let item of _data["imagesLinks"])
                    this.imagesLinks!.push(item);
            }
            else {
                this.imagesLinks = <any>null;
            }
        }
    }

    static fromJS(data: any): ArticleModelExtended {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModelExtended();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        if (Array.isArray(this.localizations)) {
            data["localizations"] = [];
            for (let item of this.localizations)
                data["localizations"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.imagesLinks)) {
            data["imagesLinks"] = [];
            for (let item of this.imagesLinks)
                data["imagesLinks"].push(item);
        }
        return data;
    }
}

export interface IArticleModelExtended {
    id: number;
    name: string;
    authorId: number;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    originalArticleLink: string | null;
    rate: number;
    localizations: IArticleLocalizationModel[] | null;
    tags: string[];
    imagesLinks: string[] | null;
}

export class ArticleModelExtendedGuidArrayValueTuple implements IArticleModelExtendedGuidArrayValueTuple {

    constructor(data?: IArticleModelExtendedGuidArrayValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ArticleModelExtendedGuidArrayValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new ArticleModelExtendedGuidArrayValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IArticleModelExtendedGuidArrayValueTuple {
}

export enum ArticleStatusRequest {
    Publish = "Publish",
    UnPublish = "UnPublish",
}

export class AuthResult implements IAuthResult {
    username!: string;
    firstName!: string;
    lastName!: string | null;
    token!: string;
    tokenExpires!: DateTime;
    refreshTokenExpires!: DateTime;
    profilePhotoUrl!: string | null;

    constructor(data?: IAuthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
            this.tokenExpires = _data["tokenExpires"] ? DateTime.fromISO(_data["tokenExpires"].toString()) : <any>null;
            this.refreshTokenExpires = _data["refreshTokenExpires"] ? DateTime.fromISO(_data["refreshTokenExpires"].toString()) : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): AuthResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        data["tokenExpires"] = this.tokenExpires ? this.tokenExpires.toString() : <any>null;
        data["refreshTokenExpires"] = this.refreshTokenExpires ? this.refreshTokenExpires.toString() : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        return data;
    }
}

export interface IAuthResult {
    username: string;
    firstName: string;
    lastName: string | null;
    token: string;
    tokenExpires: DateTime;
    refreshTokenExpires: DateTime;
    profilePhotoUrl: string | null;
}

export class CheckUserExistsResult implements ICheckUserExistsResult {
    isProviderRegistered!: boolean;

    constructor(data?: ICheckUserExistsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isProviderRegistered = _data["isProviderRegistered"] !== undefined ? _data["isProviderRegistered"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUserExistsResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUserExistsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isProviderRegistered"] = this.isProviderRegistered !== undefined ? this.isProviderRegistered : <any>null;
        return data;
    }
}

export interface ICheckUserExistsResult {
    isProviderRegistered: boolean;
}

export class CheckUsernameResult implements ICheckUsernameResult {
    isAvailable!: boolean;

    constructor(data?: ICheckUsernameResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAvailable = _data["isAvailable"] !== undefined ? _data["isAvailable"] : <any>null;
        }
    }

    static fromJS(data: any): CheckUsernameResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckUsernameResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAvailable"] = this.isAvailable !== undefined ? this.isAvailable : <any>null;
        return data;
    }
}

export interface ICheckUsernameResult {
    isAvailable: boolean;
}

export enum ContentStatus {
    Draft = "Draft",
    Pending = "Pending",
    Published = "Published",
    Banned = "Banned",
}

export class CreateArticleLocalizationRequest implements ICreateArticleLocalizationRequest {
    id!: number;
    languageCode!: string;
    title!: string;
    description!: string;
    html!: string;
    contributors!: ArticleContributorModel[] | null;

    constructor(data?: ICreateArticleLocalizationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
        }
    }

    static fromJS(data: any): CreateArticleLocalizationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArticleLocalizationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateArticleLocalizationRequest {
    id: number;
    languageCode: string;
    title: string;
    description: string;
    html: string;
    contributors: IArticleContributorModel[] | null;
}

export class CreateArticleRequest implements ICreateArticleRequest {
    name!: string;
    tags!: string[] | null;
    originalArticleLink!: string | null;

    constructor(data?: ICreateArticleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
        }
    }

    static fromJS(data: any): CreateArticleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateArticleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        return data;
    }
}

export interface ICreateArticleRequest {
    name: string;
    tags: string[] | null;
    originalArticleLink: string | null;
}

export class CryptoResponseDto implements ICryptoResponseDto {
    btc!: OneCryptoDto;
    ton!: OneCryptoDto;

    constructor(data?: ICryptoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.btc = data.btc && !(<any>data.btc).toJSON ? new OneCryptoDto(data.btc) : <OneCryptoDto>this.btc;
            this.ton = data.ton && !(<any>data.ton).toJSON ? new OneCryptoDto(data.ton) : <OneCryptoDto>this.ton;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.btc = _data["btc"] ? OneCryptoDto.fromJS(_data["btc"]) : <any>null;
            this.ton = _data["ton"] ? OneCryptoDto.fromJS(_data["ton"]) : <any>null;
        }
    }

    static fromJS(data: any): CryptoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CryptoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["btc"] = this.btc ? this.btc.toJSON() : <any>null;
        data["ton"] = this.ton ? this.ton.toJSON() : <any>null;
        return data;
    }
}

export interface ICryptoResponseDto {
    btc: IOneCryptoDto;
    ton: IOneCryptoDto;
}

export class CurrenciesResponse implements ICurrenciesResponse {
    exchanges!: ExchangeResponseModel;
    crypto!: CryptoResponseDto;
    updated!: DateTime;

    constructor(data?: ICurrenciesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.exchanges = data.exchanges && !(<any>data.exchanges).toJSON ? new ExchangeResponseModel(data.exchanges) : <ExchangeResponseModel>this.exchanges;
            this.crypto = data.crypto && !(<any>data.crypto).toJSON ? new CryptoResponseDto(data.crypto) : <CryptoResponseDto>this.crypto;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchanges = _data["exchanges"] ? ExchangeResponseModel.fromJS(_data["exchanges"]) : <any>null;
            this.crypto = _data["crypto"] ? CryptoResponseDto.fromJS(_data["crypto"]) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CurrenciesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrenciesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchanges"] = this.exchanges ? this.exchanges.toJSON() : <any>null;
        data["crypto"] = this.crypto ? this.crypto.toJSON() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        return data;
    }
}

export interface ICurrenciesResponse {
    exchanges: IExchangeResponseModel;
    crypto: ICryptoResponseDto;
    updated: DateTime;
}

export class DashboardDto implements IDashboardDto {
    articlesCount!: number;
    articlesViews!: number;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.articlesCount = _data["articlesCount"] !== undefined ? _data["articlesCount"] : <any>null;
            this.articlesViews = _data["articlesViews"] !== undefined ? _data["articlesViews"] : <any>null;
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["articlesCount"] = this.articlesCount !== undefined ? this.articlesCount : <any>null;
        data["articlesViews"] = this.articlesViews !== undefined ? this.articlesViews : <any>null;
        return data;
    }
}

export interface IDashboardDto {
    articlesCount: number;
    articlesViews: number;
}

export class ErrorDto implements IErrorDto {
    status!: number;
    type!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDto {
    status: number;
    type: string;
    message: string;

    [key: string]: any;
}

export class ErrorDetails implements IErrorDetails {
    field!: string;
    message!: string;

    [key: string]: any;

    constructor(data?: IErrorDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] !== undefined ? _data["field"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field !== undefined ? this.field : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrorDetails {
    field: string;
    message: string;

    [key: string]: any;
}

export class ExchangeResponseModel implements IExchangeResponseModel {
    usd!: OneExchangeModel;
    euro!: OneExchangeModel;

    constructor(data?: IExchangeResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.usd = data.usd && !(<any>data.usd).toJSON ? new OneExchangeModel(data.usd) : <OneExchangeModel>this.usd;
            this.euro = data.euro && !(<any>data.euro).toJSON ? new OneExchangeModel(data.euro) : <OneExchangeModel>this.euro;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usd = _data["usd"] ? OneExchangeModel.fromJS(_data["usd"]) : <any>null;
            this.euro = _data["euro"] ? OneExchangeModel.fromJS(_data["euro"]) : <any>null;
        }
    }

    static fromJS(data: any): ExchangeResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usd"] = this.usd ? this.usd.toJSON() : <any>null;
        data["euro"] = this.euro ? this.euro.toJSON() : <any>null;
        return data;
    }
}

export interface IExchangeResponseModel {
    usd: IOneExchangeModel;
    euro: IOneExchangeModel;
}

export class GetLocalizationSavingResult implements IGetLocalizationSavingResult {
    isSaved!: boolean;

    constructor(data?: IGetLocalizationSavingResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
        }
    }

    static fromJS(data: any): GetLocalizationSavingResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocalizationSavingResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        return data;
    }
}

export interface IGetLocalizationSavingResult {
    isSaved: boolean;
}

export class GetUserArticlesRequest implements IGetUserArticlesRequest {
    userName!: string | null;
    page!: number;
    perPage!: number;

    constructor(data?: IGetUserArticlesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.page = _data["page"] !== undefined ? _data["page"] : <any>null;
            this.perPage = _data["perPage"] !== undefined ? _data["perPage"] : <any>null;
        }
    }

    static fromJS(data: any): GetUserArticlesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserArticlesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["page"] = this.page !== undefined ? this.page : <any>null;
        data["perPage"] = this.perPage !== undefined ? this.perPage : <any>null;
        return data;
    }
}

export interface IGetUserArticlesRequest {
    userName: string | null;
    page: number;
    perPage: number;
}

export class LanguageModel implements ILanguageModel {
    code!: string;
    name!: string;

    constructor(data?: ILanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): LanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ILanguageModel {
    code: string;
    name: string;
}

export class OneCryptoDto implements IOneCryptoDto {
    usd!: number;
    usd24Change!: number;
    uah!: number;
    uah24Change!: number;

    constructor(data?: IOneCryptoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usd = _data["usd"] !== undefined ? _data["usd"] : <any>null;
            this.usd24Change = _data["usd24Change"] !== undefined ? _data["usd24Change"] : <any>null;
            this.uah = _data["uah"] !== undefined ? _data["uah"] : <any>null;
            this.uah24Change = _data["uah24Change"] !== undefined ? _data["uah24Change"] : <any>null;
        }
    }

    static fromJS(data: any): OneCryptoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OneCryptoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usd"] = this.usd !== undefined ? this.usd : <any>null;
        data["usd24Change"] = this.usd24Change !== undefined ? this.usd24Change : <any>null;
        data["uah"] = this.uah !== undefined ? this.uah : <any>null;
        data["uah24Change"] = this.uah24Change !== undefined ? this.uah24Change : <any>null;
        return data;
    }
}

export interface IOneCryptoDto {
    usd: number;
    usd24Change: number;
    uah: number;
    uah24Change: number;
}

export class OneExchangeModel implements IOneExchangeModel {
    currencyFrom!: string;
    currencyTo!: string;
    date!: number;
    rateBuy!: number;
    rateSell!: number;

    constructor(data?: IOneExchangeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyFrom = _data["currencyFrom"] !== undefined ? _data["currencyFrom"] : <any>null;
            this.currencyTo = _data["currencyTo"] !== undefined ? _data["currencyTo"] : <any>null;
            this.date = _data["date"] !== undefined ? _data["date"] : <any>null;
            this.rateBuy = _data["rateBuy"] !== undefined ? _data["rateBuy"] : <any>null;
            this.rateSell = _data["rateSell"] !== undefined ? _data["rateSell"] : <any>null;
        }
    }

    static fromJS(data: any): OneExchangeModel {
        data = typeof data === 'object' ? data : {};
        let result = new OneExchangeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyFrom"] = this.currencyFrom !== undefined ? this.currencyFrom : <any>null;
        data["currencyTo"] = this.currencyTo !== undefined ? this.currencyTo : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["rateBuy"] = this.rateBuy !== undefined ? this.rateBuy : <any>null;
        data["rateSell"] = this.rateSell !== undefined ? this.rateSell : <any>null;
        return data;
    }
}

export interface IOneExchangeModel {
    currencyFrom: string;
    currencyTo: string;
    date: number;
    rateBuy: number;
    rateSell: number;
}

export class PrivateUserDto implements IPrivateUserDto {
    id!: number;
    userName!: string;
    profilePhotoUrl!: string | null;

    constructor(data?: IPrivateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
        }
    }

    static fromJS(data: any): PrivateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        return data;
    }
}

export interface IPrivateUserDto {
    id: number;
    userName: string;
    profilePhotoUrl: string | null;
}

export enum ProviderType {
    Telegram = "Telegram",
    Google = "Google",
    GitHub = "GitHub",
    LinkedIn = "LinkedIn",
    Facebook = "Facebook",
}

export class RateArticleRequest implements IRateArticleRequest {
    id!: number;
    vote!: Vote;

    constructor(data?: IRateArticleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): RateArticleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RateArticleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IRateArticleRequest {
    id: number;
    vote: Vote;
}

export class RatingModel implements IRatingModel {
    vote!: Vote;

    constructor(data?: IRatingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
        }
    }

    static fromJS(data: any): RatingModel {
        data = typeof data === 'object' ? data : {};
        let result = new RatingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        return data;
    }
}

export interface IRatingModel {
    vote: Vote;
}

export class SearchUsersRequest implements ISearchUsersRequest {
    username!: string;

    constructor(data?: ISearchUsersRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
        }
    }

    static fromJS(data: any): SearchUsersRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUsersRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        return data;
    }
}

export interface ISearchUsersRequest {
    username: string;
}

export class SetArticleStatusRequest implements ISetArticleStatusRequest {
    id!: number;
    languageCode!: string;
    status!: ArticleStatusRequest;

    constructor(data?: ISetArticleStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): SetArticleStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetArticleStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data;
    }
}

export interface ISetArticleStatusRequest {
    id: number;
    languageCode: string;
    status: ArticleStatusRequest;
}

export class SetUserPhotoResult implements ISetUserPhotoResult {
    link!: string;

    constructor(data?: ISetUserPhotoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.link = _data["link"] !== undefined ? _data["link"] : <any>null;
        }
    }

    static fromJS(data: any): SetUserPhotoResult {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserPhotoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["link"] = this.link !== undefined ? this.link : <any>null;
        return data;
    }
}

export interface ISetUserPhotoResult {
    link: string;
}

export class SsoEnterRequest implements ISsoEnterRequest {
    username!: string;
    email!: string | null;
    firstName!: string | null;
    lastName!: string | null;
    middleName!: string | null;
    profilePhotoUrl!: string | null;
    providerMetadata!: { [key: string]: string; };
    provider!: ProviderType;
    providerKey!: string;
    type!: SsoType;

    constructor(data?: ISsoEnterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            if (_data["providerMetadata"]) {
                this.providerMetadata = {} as any;
                for (let key in _data["providerMetadata"]) {
                    if (_data["providerMetadata"].hasOwnProperty(key))
                        (<any>this.providerMetadata)![key] = _data["providerMetadata"][key] !== undefined ? _data["providerMetadata"][key] : <any>null;
                }
            }
            else {
                this.providerMetadata = <any>null;
            }
            this.provider = _data["provider"] !== undefined ? _data["provider"] : <any>null;
            this.providerKey = _data["providerKey"] !== undefined ? _data["providerKey"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): SsoEnterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SsoEnterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        if (this.providerMetadata) {
            data["providerMetadata"] = {};
            for (let key in this.providerMetadata) {
                if (this.providerMetadata.hasOwnProperty(key))
                    (<any>data["providerMetadata"])[key] = this.providerMetadata[key] !== undefined ? this.providerMetadata[key] : <any>null;
            }
        }
        data["provider"] = this.provider !== undefined ? this.provider : <any>null;
        data["providerKey"] = this.providerKey !== undefined ? this.providerKey : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data;
    }
}

export interface ISsoEnterRequest {
    username: string;
    email: string | null;
    firstName: string | null;
    lastName: string | null;
    middleName: string | null;
    profilePhotoUrl: string | null;
    providerMetadata: { [key: string]: string; };
    provider: ProviderType;
    providerKey: string;
    type: SsoType;
}

export enum SsoType {
    Register = "Register",
    Login = "Login",
}

export class UpdateArticleLocalizationRequest implements IUpdateArticleLocalizationRequest {
    id!: number;
    languageCode!: string;
    newLanguageCode!: string | null;
    title!: string | null;
    description!: string | null;
    html!: string | null;
    contributors!: ArticleContributorModel[] | null;

    constructor(data?: IUpdateArticleLocalizationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.contributors) {
                this.contributors = [];
                for (let i = 0; i < data.contributors.length; i++) {
                    let item = data.contributors[i];
                    this.contributors[i] = item && !(<any>item).toJSON ? new ArticleContributorModel(item) : <ArticleContributorModel>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.newLanguageCode = _data["newLanguageCode"] !== undefined ? _data["newLanguageCode"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            if (Array.isArray(_data["contributors"])) {
                this.contributors = [] as any;
                for (let item of _data["contributors"])
                    this.contributors!.push(ArticleContributorModel.fromJS(item));
            }
            else {
                this.contributors = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateArticleLocalizationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArticleLocalizationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["newLanguageCode"] = this.newLanguageCode !== undefined ? this.newLanguageCode : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        if (Array.isArray(this.contributors)) {
            data["contributors"] = [];
            for (let item of this.contributors)
                data["contributors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateArticleLocalizationRequest {
    id: number;
    languageCode: string;
    newLanguageCode: string | null;
    title: string | null;
    description: string | null;
    html: string | null;
    contributors: IArticleContributorModel[] | null;
}

export class UpdateArticleRequest implements IUpdateArticleRequest {
    id!: number;
    name!: string | null;
    authorId!: number | null;
    originalArticleLink!: string | null;

    constructor(data?: IUpdateArticleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.authorId = _data["authorId"] !== undefined ? _data["authorId"] : <any>null;
            this.originalArticleLink = _data["originalArticleLink"] !== undefined ? _data["originalArticleLink"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateArticleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateArticleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["authorId"] = this.authorId !== undefined ? this.authorId : <any>null;
        data["originalArticleLink"] = this.originalArticleLink !== undefined ? this.originalArticleLink : <any>null;
        return data;
    }
}

export interface IUpdateArticleRequest {
    id: number;
    name: string | null;
    authorId: number | null;
    originalArticleLink: string | null;
}

export class UserDto implements IUserDto {
    id!: number;
    userName!: string;
    firstName!: string;
    lastName!: string;
    middleName!: string;
    email!: string;
    profilePhotoUrl!: string | null;
    emailConfirmed!: boolean;
    description!: string | null;
    registered!: DateTime;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.profilePhotoUrl = _data["profilePhotoUrl"] !== undefined ? _data["profilePhotoUrl"] : <any>null;
            this.emailConfirmed = _data["emailConfirmed"] !== undefined ? _data["emailConfirmed"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.registered = _data["registered"] ? DateTime.fromISO(_data["registered"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["profilePhotoUrl"] = this.profilePhotoUrl !== undefined ? this.profilePhotoUrl : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["registered"] = this.registered ? this.registered.toString() : <any>null;
        return data;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    firstName: string;
    lastName: string;
    middleName: string;
    email: string;
    profilePhotoUrl: string | null;
    emailConfirmed: boolean;
    description: string | null;
    registered: DateTime;
}

export class ValidationError implements IValidationError {
    status!: number;
    type!: string;
    message!: string;
    errors!: ErrorDetails;

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.errors = data.errors && !(<any>data.errors).toJSON ? new ErrorDetails(data.errors) : <ErrorDetails>this.errors;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.errors = _data["errors"] ? ErrorDetails.fromJS(_data["errors"]) : <any>null;
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["errors"] = this.errors ? this.errors.toJSON() : <any>null;
        return data;
    }
}

export interface IValidationError {
    status: number;
    type: string;
    message: string;
    errors: IErrorDetails;

    [key: string]: any;
}

export class ViewLocalizationModel implements IViewLocalizationModel {
    userId!: number | null;
    isSaved!: boolean | null;
    savedDate!: DateTime | null;
    vote!: Vote;
    title!: string;
    description!: string;
    html!: string;
    created!: DateTime;
    updated!: DateTime | null;
    published!: DateTime | null;
    banned!: DateTime | null;
    views!: number;
    articleId!: number;
    languageCode!: string;
    status!: ContentStatus;
    localizationId!: number;
    contributorId!: number;
    contributorRole!: ArticleContributorRole;
    rate!: number;

    constructor(data?: IViewLocalizationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.isSaved = _data["isSaved"] !== undefined ? _data["isSaved"] : <any>null;
            this.savedDate = _data["savedDate"] ? DateTime.fromISO(_data["savedDate"].toString()) : <any>null;
            this.vote = _data["vote"] !== undefined ? _data["vote"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.html = _data["html"] !== undefined ? _data["html"] : <any>null;
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? DateTime.fromISO(_data["updated"].toString()) : <any>null;
            this.published = _data["published"] ? DateTime.fromISO(_data["published"].toString()) : <any>null;
            this.banned = _data["banned"] ? DateTime.fromISO(_data["banned"].toString()) : <any>null;
            this.views = _data["views"] !== undefined ? _data["views"] : <any>null;
            this.articleId = _data["articleId"] !== undefined ? _data["articleId"] : <any>null;
            this.languageCode = _data["languageCode"] !== undefined ? _data["languageCode"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.localizationId = _data["localizationId"] !== undefined ? _data["localizationId"] : <any>null;
            this.contributorId = _data["contributorId"] !== undefined ? _data["contributorId"] : <any>null;
            this.contributorRole = _data["contributorRole"] !== undefined ? _data["contributorRole"] : <any>null;
            this.rate = _data["rate"] !== undefined ? _data["rate"] : <any>null;
        }
    }

    static fromJS(data: any): ViewLocalizationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ViewLocalizationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["isSaved"] = this.isSaved !== undefined ? this.isSaved : <any>null;
        data["savedDate"] = this.savedDate ? this.savedDate.toString() : <any>null;
        data["vote"] = this.vote !== undefined ? this.vote : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["html"] = this.html !== undefined ? this.html : <any>null;
        data["created"] = this.created ? this.created.toString() : <any>null;
        data["updated"] = this.updated ? this.updated.toString() : <any>null;
        data["published"] = this.published ? this.published.toString() : <any>null;
        data["banned"] = this.banned ? this.banned.toString() : <any>null;
        data["views"] = this.views !== undefined ? this.views : <any>null;
        data["articleId"] = this.articleId !== undefined ? this.articleId : <any>null;
        data["languageCode"] = this.languageCode !== undefined ? this.languageCode : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["localizationId"] = this.localizationId !== undefined ? this.localizationId : <any>null;
        data["contributorId"] = this.contributorId !== undefined ? this.contributorId : <any>null;
        data["contributorRole"] = this.contributorRole !== undefined ? this.contributorRole : <any>null;
        data["rate"] = this.rate !== undefined ? this.rate : <any>null;
        return data;
    }
}

export interface IViewLocalizationModel {
    userId: number | null;
    isSaved: boolean | null;
    savedDate: DateTime | null;
    vote: Vote;
    title: string;
    description: string;
    html: string;
    created: DateTime;
    updated: DateTime | null;
    published: DateTime | null;
    banned: DateTime | null;
    views: number;
    articleId: number;
    languageCode: string;
    status: ContentStatus;
    localizationId: number;
    contributorId: number;
    contributorRole: ArticleContributorRole;
    rate: number;
}

export enum Vote {
    Up = "Up",
    Down = "Down",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}